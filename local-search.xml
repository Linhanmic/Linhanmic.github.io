<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>HTTP 状态码</title>
    <link href="/2024/05/05/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <url>/2024/05/05/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><h2 id="消息响应"><a href="#消息响应" class="headerlink" title="消息响应"></a>消息响应</h2><table><thead><tr><th align="left">状态码</th><th align="left">原因短语</th><th align="left">代表含义</th><th align="left">HTTP 版本</th></tr></thead><tbody><tr><td align="left">100</td><td align="left">Continue(继续)</td><td align="left">客户端应当继续发送请求.这个临时响应是用来通知客户端它的部分请求已经被服务器接收,且仍未被拒绝.客户端应当继续发送请求的剩余部分,或者如果请求已经完成,忽略这个响应.服务器必须在请求完成后向客户端发送一个最终响应.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">101</td><td align="left">Switching Protocol(切换协议)</td><td align="left">服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到 在Upgrade消息头中定义的那些协议。: 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特 性的资源。</td><td align="left">HTTP&#x2F;1.1 可用</td></tr></tbody></table><h2 id="成功响应"><a href="#成功响应" class="headerlink" title="成功响应"></a>成功响应</h2><table><thead><tr><th align="left">状态码</th><th align="left">原因短语</th><th align="left">代表含义</th><th align="left">HTTP 版本</th></tr></thead><tbody><tr><td align="left">200</td><td align="left">OK(成功)</td><td align="left">请求成功.成功的意义根据请求所使用的方法不同而不同.- GET: 资源已被提取,并作为响应体传回客户端.- HEAD: 实体头已作为响应头传回客户端- POST: 经过服务器处理客户端传来的数据,适合的资源作为响应体传回客户端.- TRACE: 服务器收到请求消息作为响应体传回客户端.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">201</td><td align="left">Created(已创建)</td><td align="left">请求成功，而且有一个新的资源已经依据请求的需要而建立，通常这是 PUT 方法得到的响应码.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">202</td><td align="left">Accepted(已创建)</td><td align="left">服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。:返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">203</td><td align="left">Non-Authoritative Information(未授权信息)</td><td align="left">服务器已成功处理了请求,但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝,如果不是上述情况,使用200状态码才是最合适的.</td><td align="left">HTTP&#x2F;0.9 and 1.1</td></tr><tr><td align="left">204</td><td align="left">No Content(无内容)</td><td align="left">该响应没有响应内容,只有响应头,响应头也可能是有用的.用户代理可以根据新的响应头来更新对应资源的缓存信息.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">205</td><td align="left">Reset Content(重置内容)</td><td align="left">告诉用户代理去重置发送该请求的窗口的文档视图.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">206</td><td align="left">Partial Content(部分内容)</td><td align="left">当客户端通过使用range头字段进行文件分段下载时使用该状态码</td><td align="left">HTTP&#x2F;1.1 可用</td></tr></tbody></table><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><table><thead><tr><th align="left">状态码</th><th align="left">原因短语</th><th align="left">代表含义</th><th align="left">HTTP 版本</th></tr></thead><tbody><tr><td align="left">300</td><td align="left">Multiple Choice(多种选择)</td><td align="left">该请求有多种可能的响应,用户代理或者用户必须选择它们其中的一个.服务器没有任何标准可以遵循去代替用户来进行选择.</td><td align="left">HTTP&#x2F;1.0 and later</td></tr><tr><td align="left">301</td><td align="left">Moved Permanently(永久移动)</td><td align="left">该状态码表示所请求的URI资源路径已经改变,新的URL会在响应的 <code>Location</code> :头字段里找到.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">302</td><td align="left">Found(临时移动)</td><td align="left">该状态码表示所请求的URI资源路径临时改变,并且还可能继续改变.因此客户端在以后访问时还得继续使用该URI.新的URL会在响应的 <code>Location:</code> 头字段里找到.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">303</td><td align="left">See Other(查看其他位置)</td><td align="left">服务器发送该响应用来引导客户端使用GET方法访问另外一个URI.</td><td align="left">HTTP&#x2F;0.9 and 1.1</td></tr><tr><td align="left">304</td><td align="left">Not Modified(未修改)</td><td align="left">告诉客户端,所请求的内容距离上次访问并没有变化. 客户端可以直接从浏览器缓存里获取该资源.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">305</td><td align="left">Use Proxy(使用代理)</td><td align="left">所请求的资源必须统过代理才能访问到.由于安全原因,该状态码并未受到广泛支持.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">306</td><td align="left">unused(未使用)</td><td align="left">这个状态码已经不再被使用,当初它被用在HTTP 1.1规范的旧版本中.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">307</td><td align="left">Temporary Redirect(临时重定向)</td><td align="left">服务器发送该响应用来引导客户端使用相同的方法访问另外一个URI来获取想要获取的资源.新的URL会在响应的 <code>Location:</code> 头字段里找到.与302状态码有相同的语义,且前后两次访问必须使用相同的方法(GET POST).</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">308</td><td align="left">Permanent Redirect(永久重定向)</td><td align="left">所请求的资源将永久的位于另外一个URI上.新的URL会在响应的 <code>Location:</code> 头字段里找到.与301状态码有相同的语义,且前后两次访问必须使用相同的方法(GET POST).</td><td align="left">HTTPbis(试验草案)</td></tr></tbody></table><h2 id="客户端错误"><a href="#客户端错误" class="headerlink" title="客户端错误"></a>客户端错误</h2><table><thead><tr><th align="left">状态码</th><th align="left">原因短语</th><th align="left">代表含义</th><th align="left">HTTP 版本</th></tr></thead><tbody><tr><td align="left">400</td><td align="left">Bad Request(错误请求)</td><td align="left">因发送的请求语法错误,服务器无法正常读取.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">401</td><td align="left">Unauthorized(未授权)</td><td align="left">需要身份验证后才能获取所请求的内容,类似于403错误.不同点是.401错误后,只要正确输入帐号密码,验证即可通过.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">402</td><td align="left">Payment Required(需要付款)</td><td align="left">该状态码被保留以供将来使用.创建此代码最初的目的是为数字支付系统而用,然而,到现在也没投入使用.</td><td align="left">HTTP&#x2F;0.9 and 1.1</td></tr><tr><td align="left">403</td><td align="left">Forbidden(禁止访问)</td><td align="left">客户端没有权利访问所请求内容,服务器拒绝本次请求.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">404</td><td align="left">Not Found(未找到)</td><td align="left">服务器找不到所请求的资源.由于经常发生此种情况,所以该状态码在上网时是非常常见的.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">405</td><td align="left">Method Not Allowed(不允许使用该方法)</td><td align="left">该请求使用的方法被服务器端禁止使用,RFC2616中规定, <code>GET</code> 和 <code>HEAD</code> 方法不能被禁止.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">406</td><td align="left">Not Acceptable(无法接受)</td><td align="left">在进行服务器驱动内容协商后,没有发现合适的内容传回给客户端.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">407</td><td align="left">Proxy Authentication Required(要求代理身份验证)</td><td align="left">类似于状态码 401,不过需要通过代理才能进行验证.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">408</td><td align="left">Request Timeout(请求超时)</td><td align="left">客户端没有在服务器预备等待的时间内完成一个请求的发送.这意味着服务器将会切断和客户端的连接. 在其他浏览器中,这种响应更常见一些, 例如Chrome 和 IE9, 目的是为了使用HTTP 预连机制加快浏览速度. 同时注意,一些服务器不发送此种响应就直接切断连接.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">409</td><td align="left">Conflict(冲突)</td><td align="left">该请求与服务器的当前状态所冲突.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">410</td><td align="left">Gone(已失效)</td><td align="left">所请求的资源已经被删除.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">411</td><td align="left">Length Required(需要内容长度头)</td><td align="left">因服务器在本次请求中需要 <code>Content-Length</code> 头字段,而客户端没有发送.所以,服务器拒绝了该请求.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">412</td><td align="left">Precondition Failed(预处理失败)</td><td align="left">服务器没能满足客户端在获取资源时在请求头字段中设置的先决条件.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">413</td><td align="left">Request Entity Too Large(请求实体过长)</td><td align="left">请求实体大小超过服务器的设置的最大限制,服务器可能会关闭HTTP链接并返回 <code>Retry-After</code> 头字段.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">414</td><td align="left">Request-URI Too Long(请求网址过长)</td><td align="left">客户端请求所包含的URI地址太长,以至于服务器无法处理.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">415</td><td align="left">Unsupported Media Type(媒体类型不支持)</td><td align="left">服务器不支持客户端所请求的媒体类型,因此拒绝该请求.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">416</td><td align="left">Requested Range Not Satisfiable(请求范围不合要求)</td><td align="left">请求中包含的 <code>Range</code> 头字段无法被满足,通常是因为 <code>Range</code> 中的数字范围超出所请求资源的大小.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">417</td><td align="left">Expectation Failed(预期结果失败)</td><td align="left">在请求头 <code> Expect</code> 中指定的预期内容无法被服务器满足.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr></tbody></table><h2 id="服务器端错误"><a href="#服务器端错误" class="headerlink" title="服务器端错误"></a>服务器端错误</h2><table><thead><tr><th align="left">状态码</th><th align="left">原因短语</th><th align="left">代表含义</th><th align="left">HTTP 版本</th></tr></thead><tbody><tr><td align="left">500</td><td align="left">Internal Server Error(内部服务器错误)</td><td align="left">服务器遇到未知的无法解决的问题.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">501</td><td align="left">Not Implemented(未实现)</td><td align="left">服务器不支持该请求中使用的方法,比如 <code>POST</code> 和 <code>PUT.只有</code> <code>GET</code> 和 <code>HEAD</code> 是RFC2616规范中规定服务器必须实现的方法.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">502</td><td align="left">Bad Gateway(网关错误)</td><td align="left">服务器作为网关且从上游服务器获取到了一个无效的HTTP响应.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">503</td><td align="left">Service Unavailable(服务不可用)</td><td align="left">由于临时的服务器维护或者过载,服务器当前无法处理请求.这个状况是临时的,并且将在一段时间以后恢复.如果能够预计延迟时间,那么响应中可以包含一个 <code>Retry-After:</code> 头用以标明这个延迟时间.如果没有给出这个 <code>Retry-After:</code> 信息，那么客户端应当以处理500响应的方式处理它.同时,这种情况下,一个友好的用于解释服务器出现问题的页面应当被返回,并且,缓存相关的HTTP头信息也应该包含,因为通常这种错误提示网页不应当被客户端缓存.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">504</td><td align="left">Gateway Timeout(网关超时)</td><td align="left">服务器作为网关且不能从上游服务器及时的得到响应返回给客户端.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">505</td><td align="left">HTTP Version Not Supported(HTTP版本不受支持)</td><td align="left">服务器不支持客户端发送的HTTP请求中所使用的HTTP协议版本.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 关闭笔记本自带键盘</title>
    <link href="/2024/04/15/Windows%E5%85%B3%E9%97%AD%E7%AC%94%E8%AE%B0%E6%9C%AC%E9%94%AE%E7%9B%98/"/>
    <url>/2024/04/15/Windows%E5%85%B3%E9%97%AD%E7%AC%94%E8%AE%B0%E6%9C%AC%E9%94%AE%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Windows-关闭笔记本自带键盘"><a href="#Windows-关闭笔记本自带键盘" class="headerlink" title="Windows 关闭笔记本自带键盘"></a>Windows 关闭笔记本自带键盘</h1><h2 id="关闭笔记本自带的键盘"><a href="#关闭笔记本自带的键盘" class="headerlink" title="关闭笔记本自带的键盘"></a>关闭笔记本自带的键盘</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">sc config i8042prt <span class="hljs-built_in">start</span> = disabled<br></code></pre></td></tr></table></figure><h2 id="打开笔记本自带的键盘"><a href="#打开笔记本自带的键盘" class="headerlink" title="打开笔记本自带的键盘"></a>打开笔记本自带的键盘</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">sc config i8042prt <span class="hljs-built_in">start</span>= auto<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Window 命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Window 命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hook malloc和free 段错误调试</title>
    <link href="/2023/10/12/Hook-malloc%E5%92%8Cfree-%E6%AE%B5%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/"/>
    <url>/2023/10/12/Hook-malloc%E5%92%8Cfree-%E6%AE%B5%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Hook-malloc-和-free-段错误调试"><a href="#Hook-malloc-和-free-段错误调试" class="headerlink" title="Hook malloc 和 free 段错误调试"></a>Hook malloc 和 free 段错误调试</h1><h2 id="1、自定义的-malloc-和-free"><a href="#1、自定义的-malloc-和-free" class="headerlink" title="1、自定义的 malloc 和 free"></a>1、自定义的 <code>malloc</code> 和 <code>free</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// my_malloc.c</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">void</span>* (*real_malloc)(<span class="hljs-type">size_t</span>) = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (!real_malloc) &#123;<br>        real_malloc = dlsym(RTLD_NEXT, <span class="hljs-string">&quot;malloc&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!real_malloc) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Error in `dlsym`: %s\n&quot;</span>, dlerror());<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">void</span>* ptr = real_malloc(size);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc(%zu) = %p\n&quot;</span>, size, ptr);<br>    <span class="hljs-keyword">return</span> ptr;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*real_free)</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span> = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (!real_free) &#123;<br>        real_free = dlsym(RTLD_NEXT, <span class="hljs-string">&quot;free&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!real_free) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Error in `dlsym`: %s\n&quot;</span>, dlerror());<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;free(%p)\n&quot;</span>, ptr);<br>    real_free(ptr);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -shared -fPIC -o libmymalloc.so my_malloc.c -ldl<br></code></pre></td></tr></table></figure><h2 id="2、测试程序"><a href="#2、测试程序" class="headerlink" title="2、测试程序"></a>2、测试程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.c</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;enter main...\n&quot;</span>);<br><br>    <span class="hljs-type">int</span> *p = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">// 分配足够的内存</span><br>    <span class="hljs-keyword">if</span> (!p) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;allocation error...\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;returning to main...\n&quot;</span>);<br><br>    <span class="hljs-built_in">free</span>(p);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>) == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hook strcmp\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;not match\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译命令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">gcc main.c libmymalloc.so -o main -g<br></code></pre></td></tr></table></figure><h2 id="3、运行结果（段错误）"><a href="#3、运行结果（段错误）" class="headerlink" title="3、运行结果（段错误）"></a>3、运行结果（段错误）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">linhanmic@MOSS:~/study$ ./main<br>Segmentation fault<br></code></pre></td></tr></table></figure><h2 id="4、gdb-调试"><a href="#4、gdb-调试" class="headerlink" title="4、gdb 调试"></a>4、gdb 调试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Temporary breakpoint 1, main () at main.c:7<br>7           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;enter main...\n&quot;</span>);<br>(gdb) n<br><br>Program received signal SIGSEGV, Segmentation fault.<br>0x00007ffff7e01097 <span class="hljs-keyword">in</span> __printf_buffer (buf=buf@entry=0x7fffff7ff370,<br>    format=format@entry=0x7ffff7fba01d <span class="hljs-string">&quot;malloc(%zu) = %p\n&quot;</span>, ap=ap@entry=0x7fffff7ff470, mode_flags=mode_flags@entry=0)<br>    at ./stdio-common/vfprintf-internal.c:600<br></code></pre></td></tr></table></figure><h2 id="5、错误分析"><a href="#5、错误分析" class="headerlink" title="5、错误分析"></a>5、错误分析</h2><p>根据调试信息发现，段错误发生在 <code>printf</code> 函数中，由于 <code>printf</code> 函数内部调用了 <code>malloc</code> ，而 hook 后的 <code>malloc</code> 内部又调用了 <code>printf</code> 函数，导致函数 <code>递归调用</code> 造成 <code>栈溢出</code>，出现 <code>Segmentation fault</code> 。</p><h2 id="6、解决方案"><a href="#6、解决方案" class="headerlink" title="6、解决方案"></a>6、解决方案</h2><p>避免在<code>malloc</code>和<code>free</code>中调用<code>printf</code>：可以使用<code>write</code>函数代替<code>printf</code>，因为<code>write</code>是一个系统调用，不会调用<code>malloc</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">void</span>* (*real_malloc)(<span class="hljs-type">size_t</span>) = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (!real_malloc) &#123;<br>        real_malloc = dlsym(RTLD_NEXT, <span class="hljs-string">&quot;malloc&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!real_malloc) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">char</span> *error = <span class="hljs-string">&quot;Error in `dlsym` for `malloc`\n&quot;</span>;<br>            write(STDERR_FILENO, error, <span class="hljs-built_in">strlen</span>(error));<br>            _exit(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">void</span>* ptr = real_malloc(size);<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">256</span>];<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">snprintf</span>(buffer, <span class="hljs-keyword">sizeof</span>(buffer), <span class="hljs-string">&quot;malloc(%zu) = %p\n&quot;</span>, size, ptr);<br>    write(STDOUT_FILENO, buffer, len);<br>    <span class="hljs-keyword">return</span> ptr;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*real_free)</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span> = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (!real_free) &#123;<br>        real_free = dlsym(RTLD_NEXT, <span class="hljs-string">&quot;free&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!real_free) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">char</span> *error = <span class="hljs-string">&quot;Error in `dlsym` for `free`\n&quot;</span>;<br>            write(STDERR_FILENO, error, <span class="hljs-built_in">strlen</span>(error));<br>            _exit(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">256</span>];<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">snprintf</span>(buffer, <span class="hljs-keyword">sizeof</span>(buffer), <span class="hljs-string">&quot;free(%p)\n&quot;</span>, ptr);<br>    write(STDOUT_FILENO, buffer, len);<br>    real_free(ptr);<br>&#125;<br></code></pre></td></tr></table></figure><p>修改后的运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">linhanmic@MOSS:~/study$ ./main<br>malloc(1024) = 0x558cae5fa2a0<br>enter main...<br>malloc(40) = 0x558cae5fa6b0<br>returning to main...<br>free(0x558cae5fa6b0)<br>not match<br></code></pre></td></tr></table></figure><h2 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h2><p>1、在 hook 时调用其他函数，由于不知道函数内部实现容易出现递归调用导致栈溢出</p><p>2、善用 <code>gdb</code> 调试程序能够快速地定位错误，达到事半功倍的效果</p>]]></content>
    
    
    
    <tags>
      
      <tag>Hook</tag>
      
      <tag>Segmentation fault</tag>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim -多行注释</title>
    <link href="/2023/09/05/Vim-%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A/"/>
    <url>/2023/09/05/Vim-%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="Vim-多行注释"><a href="#Vim-多行注释" class="headerlink" title="Vim -多行注释"></a>Vim -多行注释</h1><p>操作步骤如下：</p><ol><li>移动光标到要注释的起始行的行首</li><li>Ctrl + q 进入可视块模式</li><li>移动光标选中要注释的代码行</li><li>Shift + i 进入插入模式，键入当前语言的注释符</li><li>按Esc键后，之前选中的代码行会全部加上了注释符</li></ol><p>其实，这里并不局限于注释代码，这里的操作叫<code>列插入</code>更合适，也就是可以在多行代码的同一列插入同样的任意字符。</p>]]></content>
    
    
    
    <tags>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
