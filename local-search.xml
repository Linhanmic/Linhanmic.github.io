<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C 库函数 - fgets()</title>
    <link href="/2024/09/26/C%E5%BA%93%E5%87%BD%E6%95%B0-fgets/"/>
    <url>/2024/09/26/C%E5%BA%93%E5%87%BD%E6%95%B0-fgets/</url>
    
    <content type="html"><![CDATA[<h1 id="C-库函数-fgets"><a href="#C-库函数-fgets" class="headerlink" title="C 库函数 - fgets()"></a>C 库函数 - <code>fgets()</code></h1><p>头文件 <code>&lt;stdio.h&gt;</code></p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p>C 库函数 <code>char *fgets(char *str, int n, FILE *stream)</code> 从指定的流 <code>stream</code> 读取一行，并把它存储在 <code>str</code> 所指向的字符串内。当读取 <code>(n-1)</code> 个字符时，或者读取到换行符时，或者到达文件末尾时，它会停止，具体视情况而定。</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">char</span> *<span class="hljs-title function_">fgets</span><span class="hljs-params">(<span class="hljs-type">char</span> *str, <span class="hljs-type">int</span> n, FILE *stream)</span>;<br></code></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li><strong>str</strong>：这是指向一个字符数组的指针，该数组存储了要读取的字符串。</li><li><strong>n</strong>：这是要读取的最大字符数（包括最后的空字符）。通常是使用以 <code>str</code> 传递的数组长度。</li><li><strong>stream</strong>：这是指向 <code>FILE</code> 对象的指针，该 <code>FILE</code> 对象标识了要从中读取字符的流。</li></ul><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p>如果成功，该函数返回相同的 <code>str</code> 参数。如果到达文件末尾或者没有读取到任何字符，<code>str</code> 的内容保持不变，并返回一个空指针。</p><p>如果发生错误，返回一个空指针。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    FILE *file;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">100</span>];<br><br>    <span class="hljs-comment">// 打开文件以读取</span><br>    file = fopen(<span class="hljs-string">&quot;example.txt&quot;</span>, <span class="hljs-string">&quot;r&quot;</span>);<br>    <span class="hljs-keyword">if</span> (file == <span class="hljs-literal">NULL</span>) &#123;<br>        perror(<span class="hljs-string">&quot;Error opening file&quot;</span>);<br>        <span class="hljs-keyword">return</span> <span class="hljs-number">-1</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 使用 fgets 读取文件中的一行</span><br>    <span class="hljs-keyword">if</span> (fgets(buffer, <span class="hljs-keyword">sizeof</span>(buffer), file) != <span class="hljs-literal">NULL</span>) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Read line: %s\n&quot;</span>, buffer);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Error or end of file reached\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 关闭文件</span><br>    fclose(file);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>fgets()</code> 从文件 <code>example.txt</code> 中读取一行，并将其存储在 <code>buffer</code> 中。如果读取成功，打印读取的行；如果发生错误或到达文件末尾，打印相应的消息。</p>]]></content>
    
    
    <categories>
      
      <category>C</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>I/O 函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C 库函数 - snprintf()</title>
    <link href="/2024/09/26/C%E5%BA%93%E5%87%BD%E6%95%B0-snprintf/"/>
    <url>/2024/09/26/C%E5%BA%93%E5%87%BD%E6%95%B0-snprintf/</url>
    
    <content type="html"><![CDATA[<h1 id="C-库函数-snprintf"><a href="#C-库函数-snprintf" class="headerlink" title="C 库函数 - snprintf()"></a>C 库函数 - <code>snprintf()</code></h1><p>头文件 <code>&lt;stdio.h&gt;</code></p><h2 id="描述"><a href="#描述" class="headerlink" title="描述"></a>描述</h2><p><code>snprintf()</code> 是一个 C 语言标准库函数，用于格式化输出字符串，并将结果写入到指定的缓冲区。与 <code>sprintf()</code> 不同的是，<code>snprintf()</code> 会限制输出的字符数，避免缓冲区溢出。</p><p>C 库函数 <strong>int snprintf(char *str, size_t size, const char *format, …)</strong> 将可变参数 <strong>(…)</strong> 按照 <strong>format</strong> 格式化成字符串，并将字符串复制到 <strong>str</strong> 中，<strong>size</strong> 为要写入的字符的最大数目，超过 <strong>size</strong> 会被截断，最多写入 <code>size-1</code> 个字符。</p><p>与 <a href="https://www.runoob.com/cprogramming/c-function-sprintf.html">sprintf()</a> 函数不同的是，<code>snprintf()</code> 函数提供了一个参数 <code>size</code>，可以防止缓冲区溢出。如果格式化后的字符串长度超过了 <code>size-1</code>，则 <code>snprintf()</code> 只会写入 <code>size-1</code> 个字符，并在字符串的末尾添加一个空字符（<code>\0</code>）以表示字符串的结束。</p><h2 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-type">int</span> <span class="hljs-title function_">snprintf</span><span class="hljs-params">(<span class="hljs-type">char</span> *str, <span class="hljs-type">size_t</span> size, <span class="hljs-type">const</span> <span class="hljs-type">char</span> *format, ...)</span>;<br></code></pre></td></tr></table></figure><h2 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h2><ul><li><strong>str</strong>：目标字符串，用于存储格式化后的字符串的字符数组的指针。</li><li><strong>size</strong>：字符数组的大小。</li><li><strong>format</strong>：格式化字符串。</li><li>**…**：可变参数，根据 <code>format</code> 中的格式化指令进行格式化。</li></ul><h2 id="返回值"><a href="#返回值" class="headerlink" title="返回值"></a>返回值</h2><p><code>snprintf()</code> 函数的返回值是输出到 <code>str</code> 缓冲区中的字符数，不包括字符串结尾的空字符 <code>\0</code>。如果 <code>snprintf()</code> 输出的字符数超过了 <code>size</code> 参数指定的缓冲区大小，则输出的结果会被截断，只有 <code>size - 1</code> 个字符被写入缓冲区，最后一个字符为字符串结尾的空字符 <code>\0</code>。</p><p>需要注意的是，<code>snprintf()</code> 函数返回的字符数并不包括字符串结尾的空字符 <code>\0</code>，因此如果需要将输出结果作为一个字符串使用，则需要在缓冲区的末尾添加一个空字符 <code>\0</code>。</p><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span> &#123;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">50</span>];<br>    <span class="hljs-type">int</span> n;<br><br>    n = <span class="hljs-built_in">snprintf</span>(buffer, <span class="hljs-keyword">sizeof</span>(buffer), <span class="hljs-string">&quot;Hello, %s!&quot;</span>, <span class="hljs-string">&quot;World&quot;</span>);<br><br>    <span class="hljs-keyword">if</span> (n &gt;= <span class="hljs-number">0</span> &amp;&amp; n &lt; <span class="hljs-keyword">sizeof</span>(buffer)) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Formatted string: %s\n&quot;</span>, buffer);<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;Buffer size is too small. Required size: %d\n&quot;</span>, n + <span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>snprintf()</code> 将格式化后的字符串写入 <code>buffer</code> 中，并确保不会超过缓冲区的大小。</p>]]></content>
    
    
    
    <tags>
      
      <tag>C</tag>
      
      <tag>字符串</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gRPC 状态码枚举文档</title>
    <link href="/2024/09/26/gRPC%E7%8A%B6%E6%80%81%E7%A0%81%E6%9E%9A%E4%B8%BE%E6%96%87%E6%A1%A3/"/>
    <url>/2024/09/26/gRPC%E7%8A%B6%E6%80%81%E7%A0%81%E6%9E%9A%E4%B8%BE%E6%96%87%E6%A1%A3/</url>
    
    <content type="html"><![CDATA[<h3 id="gRPC-状态码枚举文档"><a href="#gRPC-状态码枚举文档" class="headerlink" title="gRPC 状态码枚举文档"></a>gRPC 状态码枚举文档</h3><p>gRPC 框架定义了一系列的状态码，用于表示远程过程调用（RPC）的结果。以下是 <code>grpc</code> 命名空间中 <code>StatusCode</code> 枚举的详细说明：</p><h4 id="OK-0"><a href="#OK-0" class="headerlink" title="OK (0)"></a>OK (0)</h4><ul><li><strong>操作成功，没有错误。</strong></li><li><strong>常见使用场景</strong>：远程过程调用成功完成。</li><li><strong>错误处理建议</strong>：无需采取任何错误处理措施，正常流程。</li></ul><h4 id="CANCELLED-1"><a href="#CANCELLED-1" class="headerlink" title="CANCELLED (1)"></a>CANCELLED (1)</h4><ul><li><strong>操作被取消，通常是调用方主动请求的。</strong></li><li><strong>常见使用场景</strong>：调用方在操作完成前取消了请求。</li><li><strong>错误处理建议</strong>：检查调用逻辑，确保在取消请求时释放资源，避免内存泄漏。</li></ul><h4 id="UNKNOWN-2"><a href="#UNKNOWN-2" class="headerlink" title="UNKNOWN (2)"></a>UNKNOWN (2)</h4><ul><li><strong>未知错误。如果从另一个地址空间接收到的状态值属于在此地址空间未知的错误空间，或者API没有返回足够的错误信息，可能会返回此错误。</strong></li><li><strong>常见使用场景</strong>：系统内部错误，或者接收到来自未知错误空间的状态。</li><li><strong>错误处理建议</strong>：记录错误详情，尝试重新执行操作，如果问题持续，可能需要联系系统管理员。</li></ul><h4 id="INVALID-ARGUMENT-3"><a href="#INVALID-ARGUMENT-3" class="headerlink" title="INVALID_ARGUMENT (3)"></a>INVALID_ARGUMENT (3)</h4><ul><li><strong>客户端指定了无效的参数。与 <code>FAILED_PRECONDITION</code> 不同，<code>INVALID_ARGUMENT</code> 表示无论系统状态如何，参数本身都是有问题的（例如，文件名格式错误）。</strong></li><li><strong>常见使用场景</strong>：调用方提供了不合规范的参数。</li><li><strong>错误处理建议</strong>：验证输入参数的有效性，提供清晰的错误信息给调用方。</li></ul><h4 id="DEADLINE-EXCEEDED-4"><a href="#DEADLINE-EXCEEDED-4" class="headerlink" title="DEADLINE_EXCEEDED (4)"></a>DEADLINE_EXCEEDED (4)</h4><ul><li><strong>操作在完成前已超时。对于改变系统状态的操作，即使操作本身已经成功完成，也可能返回此错误。例如，即使服务器的响应是成功的，如果响应延迟导致超时，也可能返回此错误。</strong></li><li><strong>常见使用场景</strong>：操作因超时而未能完成。</li><li><strong>错误处理建议</strong>：根据操作性质决定是否重试，考虑增加超时时间或优化性能。</li></ul><h4 id="NOT-FOUND-5"><a href="#NOT-FOUND-5" class="headerlink" title="NOT_FOUND (5)"></a>NOT_FOUND (5)</h4><ul><li><strong>请求的实体（如文件或目录）未找到。</strong></li><li><strong>常见使用场景</strong>：请求的资源（如文件、目录或数据库记录）不存在。</li><li><strong>错误处理建议</strong>：确认资源路径或标识符，提供错误信息并可能要求用户重新输入。</li></ul><h4 id="ALREADY-EXISTS-6"><a href="#ALREADY-EXISTS-6" class="headerlink" title="ALREADY_EXISTS (6)"></a>ALREADY_EXISTS (6)</h4><ul><li><strong>尝试创建的实体（如文件或目录）已存在。</strong></li><li><strong>常见使用场景</strong>：尝试创建已存在的资源。</li><li><strong>错误处理建议</strong>：检查资源是否已存在，提供更新或删除现有资源的选项。</li></ul><h4 id="PERMISSION-DENIED-7"><a href="#PERMISSION-DENIED-7" class="headerlink" title="PERMISSION_DENIED (7)"></a>PERMISSION_DENIED (7)</h4><ul><li><strong>调用者没有执行指定操作的权限。<code>PERMISSION_DENIED</code> 不应用于因资源耗尽导致的拒绝（应使用 <code>RESOURCE_EXHAUSTED</code>），也不应用于无法识别调用者的情况（应使用 <code>UNAUTHENTICATED</code>）。</strong></li><li><strong>常见使用场景</strong>：调用方没有足够的权限执行操作。</li><li><strong>错误处理建议</strong>：要求调用方提供适当的权限或认证信息。</li></ul><h4 id="RESOURCE-EXHAUSTED-8"><a href="#RESOURCE-EXHAUSTED-8" class="headerlink" title="RESOURCE_EXHAUSTED (8)"></a>RESOURCE_EXHAUSTED (8)</h4><ul><li><strong>资源耗尽，可能是每个用户的配额，或者整个文件系统没有空间。</strong></li><li><strong>常见使用场景</strong>：系统资源耗尽，如达到API调用配额限制。</li><li><strong>错误处理建议</strong>：实施资源配额管理，提示用户减少请求频率或升级服务。</li></ul><h4 id="FAILED-PRECONDITION-9"><a href="#FAILED-PRECONDITION-9" class="headerlink" title="FAILED_PRECONDITION (9)"></a>FAILED_PRECONDITION (9)</h4><ul><li><strong>操作因系统不在操作执行所需的状态而被拒绝。例如，要删除的目录可能不为空，或者对非目录应用了删除操作等。</strong></li><li><strong>常见使用场景</strong>：操作依赖于特定的系统状态，而当前状态不满足要求。</li><li><strong>错误处理建议</strong>：确保所有前提条件都满足后再重试操作。</li></ul><h4 id="ABORTED-10"><a href="#ABORTED-10" class="headerlink" title="ABORTED (10)"></a>ABORTED (10)</h4><ul><li><strong>由于并发问题（如序列号检查失败、事务中止等）通常会导致操作中止。</strong></li><li><strong>常见使用场景</strong>：由于并发问题，如事务冲突，操作被中止。</li><li><strong>错误处理建议</strong>：检查并发控制机制，可能需要重试或调整事务逻辑。</li></ul><h4 id="OUT-OF-RANGE-11"><a href="#OUT-OF-RANGE-11" class="headerlink" title="OUT_OF_RANGE (11)"></a>OUT_OF_RANGE (11)</h4><ul><li><strong>操作尝试超出有效范围。例如，尝试读取文件末尾之后的内容。</strong></li><li><strong>常见使用场景</strong>：操作尝试超出了有效范围，如索引超出数组界限。</li><li><strong>错误处理建议</strong>：检查索引或范围参数，确保它们在有效范围内。</li></ul><h4 id="UNIMPLEMENTED-12"><a href="#UNIMPLEMENTED-12" class="headerlink" title="UNIMPLEMENTED (12)"></a>UNIMPLEMENTED (12)</h4><ul><li><strong>操作未实现或在此服务中不支持&#x2F;未启用。</strong></li><li><strong>常见使用场景</strong>：请求的方法或功能在服务中未被实现。</li><li><strong>错误处理建议</strong>：提示调用方该功能不可用，或提供替代方案。</li></ul><h4 id="INTERNAL-13"><a href="#INTERNAL-13" class="headerlink" title="INTERNAL (13)"></a>INTERNAL (13)</h4><ul><li><strong>内部错误。意味着底层系统预期的一些不变量已被破坏。如果看到这些错误，说明有严重的问题。</strong></li><li><strong>常见使用场景</strong>：内部错误，如系统崩溃或严重的程序错误。</li><li><strong>错误处理建议</strong>：记录错误详情，尝试重启服务或联系技术支持。</li></ul><h4 id="UNAVAILABLE-14"><a href="#UNAVAILABLE-14" class="headerlink" title="UNAVAILABLE (14)"></a>UNAVAILABLE (14)</h4><ul><li><strong>服务当前不可用。这很可能是暂时性的条件，通过带有退避的重试可能会得到纠正。注意，对于非幂等操作，重试并不总是安全的。</strong></li><li><strong>常见使用场景</strong>：服务不可用，可能是由于过载或维护。</li><li><strong>错误处理建议</strong>：实施重试机制，增加退避策略，或提示用户稍后再试。</li></ul><h4 id="DATA-LOSS-15"><a href="#DATA-LOSS-15" class="headerlink" title="DATA_LOSS (15)"></a>DATA_LOSS (15)</h4><ul><li><strong>不可恢复的数据丢失或损坏。</strong></li><li><strong>常见使用场景</strong>：数据丢失或损坏，无法恢复。</li><li><strong>错误处理建议</strong>：尝试从备份中恢复数据，如果没有备份，可能需要手动重建丢失的数据。</li></ul><h4 id="UNAUTHENTICATED-16"><a href="#UNAUTHENTICATED-16" class="headerlink" title="UNAUTHENTICATED (16)"></a>UNAUTHENTICATED (16)</h4><ul><li><strong>请求没有有效的认证凭据进行操作。</strong></li><li><strong>常见使用场景</strong>：调用方未提供有效的认证凭据。</li><li><strong>错误处理建议</strong>：要求调用方进行认证。</li></ul><h4 id="DO-NOT-USE-1"><a href="#DO-NOT-USE-1" class="headerlink" title="DO_NOT_USE (-1)"></a>DO_NOT_USE (-1)</h4><ul><li><strong>强制用户包含一个默认分支。</strong></li><li><strong>常见使用场景</strong>：这是一个保留值，不应用于实际的错误状态。</li><li><strong>错误处理建议</strong>：如果遇到此状态码，检查代码逻辑，确保没有错误地使用此值。</li></ul>]]></content>
    
    
    
    <tags>
      
      <tag>gRPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>gRPC 基本使用</title>
    <link href="/2024/09/26/gRPC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/"/>
    <url>/2024/09/26/gRPC%E5%9F%BA%E6%9C%AC%E4%BD%BF%E7%94%A8/</url>
    
    <content type="html"><![CDATA[<h1 id="gRPC-基本使用"><a href="#gRPC-基本使用" class="headerlink" title="gRPC 基本使用"></a>gRPC 基本使用</h1><p> gRPC 是一个高性能、开源且通用的远程过程调用 (RPC) 框架，它能够让你从客户端轻松地调用另一台机器上的服务端方法，就像调用本地对象一样，同时为你管理了很多细节，如线程管理和网络传输等。gRPC 支持多种语言，并且默认使用 Protocol Buffers 作为接口定义语言（IDL）来定义服务接口以及消息格式。</p><p>下面是 gRPC 的基本使用步骤：</p><h2 id="1、定义服务接口"><a href="#1、定义服务接口" class="headerlink" title="1、定义服务接口"></a>1、定义服务接口</h2><p>首先使用 protobuf 语言定义服务接口，定义在以 <code>.proto</code> 结尾的文件中，其中包含了服务的名称、服务的方法以及每个方法的消息格式。</p><figure class="highlight protobuf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs protobuf"><span class="hljs-comment">// 指定使用的 Protocol Buffers 版本为 proto3。</span><br>syntax = <span class="hljs-string">&quot;proto3&quot;</span>;<br><br><span class="hljs-comment">// 定义了一个名为 `example` 的包。所有的消息和服务都属于这个包。相当于C++的命名空间</span><br><span class="hljs-keyword">package</span> example;<br><br><span class="hljs-comment">// 定义了一个名为 `Echo` 的服务。</span><br><span class="hljs-comment">// 服务定义了可以被远程调用的方法。</span><br><span class="hljs-keyword">service </span><span class="hljs-title class_">Echo</span> &#123;<br>    <span class="hljs-comment">// `SayHello` 是一个远程过程调用方法。</span><br>    <span class="hljs-comment">// 它接收一个 `HelloRequest` 类型的消息作为参数，</span><br>    <span class="hljs-comment">// 并返回一个 `HelloResponse` 类型的消息。</span><br>    <span class="hljs-function"><span class="hljs-keyword">rpc</span> SayHello (HelloRequest) <span class="hljs-keyword">returns</span> (HelloResponse)</span>;<br>&#125;<br><br><span class="hljs-comment">// 定义了一个名为 `HelloRequest` 的消息类型。</span><br><span class="hljs-comment">// 这个消息有一个字段 `greeting`，类型为 `string`。</span><br><span class="hljs-comment">// 字段的序号为 1，这意味着在序列化过程中，它会被编码为第一个字段。</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloRequest</span> &#123;<br>    <span class="hljs-type">string</span> greeting = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 请求消息体中的字符串字段</span><br>&#125;<br><br><span class="hljs-comment">// 定义了一个名为 `HelloResponse` 的消息类型。</span><br><span class="hljs-comment">// 这个消息有一个字段 `reply`，类型为 `string`。</span><br><span class="hljs-comment">// 字段的序号为 1，这意味着在序列化过程中，它会被编码为第一个字段。</span><br><span class="hljs-keyword">message </span><span class="hljs-title class_">HelloResponse</span> &#123;<br>    <span class="hljs-type">string</span> reply = <span class="hljs-number">1</span>;  <span class="hljs-comment">// 响应消息体中的字符串字段</span><br>&#125;<br></code></pre></td></tr></table></figure><h2 id="2、生成代码"><a href="#2、生成代码" class="headerlink" title="2、生成代码"></a>2、生成代码</h2><p>使用 Protocol Buffers 编译器 (<code>protoc</code>) 和相应语言对应的 gRPC 插件生成客户端和服务器端的存根代码。</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs bash">// 生成 c++ 消息类: echo.pb.h echo.pb.cc<br>protoc -I=. --cpp_out=. echo.proto<br>// 生成 gRPC 存根代码: echo.grpc.pb.h ehco.grpc.pb.cc<br>protoc -I=. --grpc_out=. --plugin=protoc-gen-grpc=`<span class="hljs-built_in">which</span> grpc_cpp_plugin` echo.proto<br></code></pre></td></tr></table></figure><p>protoc 命令解析</p><p><code>-I</code>：指定 <code>.proto</code> 文件的搜索路径</p><p><code>--cpp_out</code>：指定生成 C++ 代码的输出路径</p><p><code>--grpc_out</code>：指定生成 gRPC 存根代码的输出路径</p><p><code>--plugin=proto-gen-grpc=&#39;which grpc_cpp_plugin&#39;</code>：指定要使用的插件</p><h2 id="3、实现服务"><a href="#3、实现服务" class="headerlink" title="3、实现服务"></a>3、实现服务</h2><p>继承自动生成的服务类并实现其中的虚函数。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-keyword">class</span> <span class="hljs-title class_">EchoServiceImpl</span> <span class="hljs-keyword">final</span> : <span class="hljs-keyword">public</span> example::Echo::Service &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function">grpc::Status <span class="hljs-title">SayHello</span><span class="hljs-params">(grpc::ServerContext* context, <span class="hljs-type">const</span> example::HelloRequest* request,</span></span><br><span class="hljs-params"><span class="hljs-function">                          example::HelloResponse* reply)</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-function">std::string <span class="hljs-title">prefix</span><span class="hljs-params">(<span class="hljs-string">&quot;Hello &quot;</span>)</span></span>;<br>        reply-&gt;<span class="hljs-built_in">set_reply</span>(prefix + request-&gt;<span class="hljs-built_in">greeting</span>());<br>        <span class="hljs-keyword">return</span> grpc::Status::OK;<br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h2 id="4、创建服务器"><a href="#4、创建服务器" class="headerlink" title="4、创建服务器"></a>4、创建服务器</h2><p>创建一个 gRPC 服务实例，并将实现的服务注册到服务器上。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-comment">// 导入 gRPC 相关头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;grpcpp/grpcpp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;example.pb.h&quot;</span>  <span class="hljs-comment">// 自动生成的消息头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;example.grpc.pb.h&quot;</span>  <span class="hljs-comment">// 自动生成的服务头文件</span></span><br><br><span class="hljs-comment">// 主函数</span><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">(<span class="hljs-type">int</span> argc, <span class="hljs-type">char</span>** argv)</span> </span>&#123;<br>    <span class="hljs-comment">// 服务器监听地址</span><br>    <span class="hljs-function">std::string <span class="hljs-title">server_address</span><span class="hljs-params">(<span class="hljs-string">&quot;0.0.0.0:50051&quot;</span>)</span></span>;<br><br>    <span class="hljs-comment">// 创建服务实例</span><br>    EchoServiceImpl service;<br><br>    <span class="hljs-comment">// 创建 ServerBuilder 对象</span><br>    grpc::ServerBuilder builder;<br><br>    <span class="hljs-comment">// 添加监听端口</span><br>    <span class="hljs-comment">// 使用不安全的凭证（仅适用于开发环境）</span><br>    builder.<span class="hljs-built_in">AddListeningPort</span>(server_address, grpc::<span class="hljs-built_in">InsecureServerCredentials</span>());<br><br>    <span class="hljs-comment">// 注册服务</span><br>    <span class="hljs-comment">// 将服务实例注册到 ServerBuilder 中</span><br>    builder.<span class="hljs-built_in">RegisterService</span>(&amp;service);<br><br>    <span class="hljs-comment">// 构建并启动服务器</span><br>    <span class="hljs-comment">// BuildAndStart() 方法返回一个 unique_ptr 指向 Server 对象</span><br>    <span class="hljs-function">std::unique_ptr&lt;grpc::Server&gt; <span class="hljs-title">server</span><span class="hljs-params">(builder.BuildAndStart())</span></span>;<br><br>    <span class="hljs-comment">// 输出服务器监听地址</span><br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Server listening on &quot;</span> &lt;&lt; server_address &lt;&lt; std::endl;<br><br>    <span class="hljs-comment">// 等待服务器关闭</span><br>    <span class="hljs-comment">// 这里阻塞主线程，等待服务器关闭</span><br>    server-&gt;<span class="hljs-built_in">Wait</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="5、创建客户端"><a href="#5、创建客户端" class="headerlink" title="5、创建客户端"></a>5、创建客户端</h2><p>创建一个客户端实例连接到 gRPC 服务器，并调用服务的方法。</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;memory&gt;</span></span><br><br><span class="hljs-comment">// 导入 gRPC 相关头文件</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;grpcpp/grpcpp.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;example.pb.h&quot;</span>  <span class="hljs-comment">// 自动生成的消息头文件</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;example.grpc.pb.h&quot;</span>  <span class="hljs-comment">// 自动生成的服务头文件</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 创建一个 gRPC 通道</span><br>    <span class="hljs-comment">// 通道用于与远程服务器通信</span><br>    std::shared_ptr&lt;grpc::Channel&gt; channel = grpc::<span class="hljs-built_in">CreateChannel</span>(<br>        <span class="hljs-string">&quot;localhost:50051&quot;</span>, grpc::<span class="hljs-built_in">InsecureChannelCredentials</span>());<br><br>    <span class="hljs-comment">// 创建服务存根</span><br>    <span class="hljs-comment">// 存根用于发起 RPC 调用</span><br>    std::unique_ptr&lt;example::Echo::Stub&gt; stub = example::Echo::<span class="hljs-built_in">NewStub</span>(channel);<br><br>    <span class="hljs-comment">// 创建请求消息</span><br>    example::HelloRequest request;<br>    request.<span class="hljs-built_in">set_greeting</span>(<span class="hljs-string">&quot;world&quot;</span>);<br><br>    <span class="hljs-comment">// 创建响应消息</span><br>    example::HelloResponse reply;<br><br>    <span class="hljs-comment">// 创建客户端上下文</span><br>    <span class="hljs-comment">// 用于传递额外的信息，如元数据、截止时间等</span><br>    grpc::ClientContext context;<br><br>    <span class="hljs-comment">// 发起 RPC 调用</span><br>    <span class="hljs-comment">// SayHello 方法接收请求消息并返回响应消息</span><br>    grpc::Status status = stub-&gt;<span class="hljs-built_in">SayHello</span>(&amp;context, request, &amp;reply);<br><br>    <span class="hljs-comment">// 检查 RPC 调用的状态</span><br>    <span class="hljs-keyword">if</span> (status.<span class="hljs-built_in">ok</span>()) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Greeter received: &quot;</span> &lt;&lt; reply.<span class="hljs-built_in">reply</span>() &lt;&lt; std::endl;<br>    &#125; <span class="hljs-keyword">else</span> &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Greeter RPC failed: &quot;</span> &lt;&lt; status.<span class="hljs-built_in">error_code</span>() &lt;&lt; <span class="hljs-string">&quot;: &quot;</span> &lt;&lt; status.<span class="hljs-built_in">error_message</span>() &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>gRPC</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>gRPC</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>对象初始化和函数声明的语法可能会产生歧义</title>
    <link href="/2024/09/24/%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E7%9A%84%E8%AF%AD%E6%B3%95%E5%8F%AF%E8%83%BD%E4%BC%9A%E4%BA%A7%E7%94%9F%E6%AD%A7%E4%B9%89/"/>
    <url>/2024/09/24/%E5%AF%B9%E8%B1%A1%E5%88%9D%E5%A7%8B%E5%8C%96%E5%92%8C%E5%87%BD%E6%95%B0%E5%A3%B0%E6%98%8E%E7%9A%84%E8%AF%AD%E6%B3%95%E5%8F%AF%E8%83%BD%E4%BC%9A%E4%BA%A7%E7%94%9F%E6%AD%A7%E4%B9%89/</url>
    
    <content type="html"><![CDATA[<h1 id="对象初始化和函数声明的语法可能会产生歧义"><a href="#对象初始化和函数声明的语法可能会产生歧义" class="headerlink" title="对象初始化和函数声明的语法可能会产生歧义"></a><strong>对象初始化和函数声明的语法可能会产生歧义</strong></h1><p>在C++中，有时对象初始化和函数声明的语法可能会产生歧义，导致编译器无法正确解析代码。这种情况被称为“最令人困惑的解析”（Most Vexing Parse）。为了避免这种歧义，可以使用额外的括号或其他语法技巧来明确表达意图。</p><h3 id="示例：最令人困惑的解析"><a href="#示例：最令人困惑的解析" class="headerlink" title="示例：最令人困惑的解析"></a>示例：最令人困惑的解析</h3><p>假设我们有以下代码：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">numbers</span><span class="hljs-params">(std::istream_iterator&lt;<span class="hljs-type">int</span>&gt;(iss), std::istream_iterator&lt;<span class="hljs-type">int</span>&gt;())</span></span>;<br></code></pre></td></tr></table></figure><p>编译器可能会将其解释为一个函数声明，而不是对象的初始化。为了避免这种情况，我们可以使用额外的括号来明确表示这是一个对象的初始化：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">numbers</span><span class="hljs-params">((std::istream_iterator&lt;<span class="hljs-type">int</span>&gt;(iss)), std::istream_iterator&lt;<span class="hljs-type">int</span>&gt;())</span></span>;<br></code></pre></td></tr></table></figure><h3 id="详细解释"><a href="#详细解释" class="headerlink" title="详细解释"></a>详细解释</h3><ul><li><code>std::istream_iterator&lt;int&gt;(iss)</code>：创建一个从输入流 <code>iss</code> 中读取整数的迭代器。</li><li><code>std::istream_iterator&lt;int&gt;()</code>：创建一个默认构造的流迭代器，表示流的结束。</li><li><code>std::vector&lt;int&gt;</code> 的构造函数接受两个迭代器，表示要复制的范围。</li></ul><h3 id="其他避免歧义的方法"><a href="#其他避免歧义的方法" class="headerlink" title="其他避免歧义的方法"></a>其他避免歧义的方法</h3><p>除了使用额外的括号，还可以使用其他方法来避免歧义，例如使用C++11引入的列表初始化语法：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp">std::vector&lt;<span class="hljs-type">int</span>&gt; numbers&#123;std::<span class="hljs-built_in">istream_iterator</span>&lt;<span class="hljs-type">int</span>&gt;(iss), std::<span class="hljs-built_in">istream_iterator</span>&lt;<span class="hljs-type">int</span>&gt;()&#125;;<br></code></pre></td></tr></table></figure><p>这种语法明确表示这是一个对象的初始化，而不是函数声明。</p><h3 id="示例代码"><a href="#示例代码" class="headerlink" title="示例代码"></a>示例代码</h3><p>以下是使用额外括号和列表初始化语法的完整示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;sstream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;vector&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iterator&gt;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    std::string str&#123;<span class="hljs-string">&quot;1 2 3 4 5&quot;</span>&#125;;<br>    <span class="hljs-function">std::istringstream <span class="hljs-title">iss</span><span class="hljs-params">(str)</span></span>;<br><br>    <span class="hljs-comment">// 使用额外括号避免歧义</span><br>    <span class="hljs-function">std::vector&lt;<span class="hljs-type">int</span>&gt; <span class="hljs-title">numbers1</span><span class="hljs-params">((std::istream_iterator&lt;<span class="hljs-type">int</span>&gt;(iss)), std::istream_iterator&lt;<span class="hljs-type">int</span>&gt;())</span></span>;<br><br>    <span class="hljs-comment">// 使用列表初始化语法避免歧义</span><br>    <span class="hljs-function">std::istringstream <span class="hljs-title">iss2</span><span class="hljs-params">(str)</span></span>; <span class="hljs-comment">// 重新初始化流，因为上面的流已经被读取完毕</span><br>    std::vector&lt;<span class="hljs-type">int</span>&gt; numbers2&#123;std::<span class="hljs-built_in">istream_iterator</span>&lt;<span class="hljs-type">int</span>&gt;(iss2), std::<span class="hljs-built_in">istream_iterator</span>&lt;<span class="hljs-type">int</span>&gt;()&#125;;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : numbers1) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br>    std::cout &lt;&lt; std::endl;<br><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> num : numbers2) &#123;<br>        std::cout &lt;&lt; num &lt;&lt; <span class="hljs-string">&quot; &quot;</span>;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><p>为了避免对象初始化和函数声明之间的歧义，可以使用额外的括号或列表初始化语法。这些方法可以确保编译器正确解析代码，避免最令人困惑的解析问题。</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>初始化</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>维吉尼亚加密和解密算法</title>
    <link href="/2024/09/24/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/"/>
    <url>/2024/09/24/%E7%BB%B4%E5%90%89%E5%B0%BC%E4%BA%9A%E5%8A%A0%E5%AF%86%E5%92%8C%E8%A7%A3%E5%AF%86%E7%AE%97%E6%B3%95/</url>
    
    <content type="html"><![CDATA[<h1 id="维吉尼亚加密和解密算法"><a href="#维吉尼亚加密和解密算法" class="headerlink" title="维吉尼亚加密和解密算法"></a>维吉尼亚加密和解密算法</h1><h3 id="1-算法概述"><a href="#1-算法概述" class="headerlink" title="1. 算法概述"></a>1. 算法概述</h3><p>维吉尼亚加密是一种基于多表代换的加密方法，它使用一个密钥对明文进行加密。每个字母的加密和解密都依赖于密钥中的相应字母。</p><p>核心：根据字母表将字符串翻译成数字,  然后将其按照密钥个数进行分组，分别与秘钥集合相加，得到密文。</p><h3 id="2-加密过程"><a href="#2-加密过程" class="headerlink" title="2. 加密过程"></a>2. 加密过程</h3><ol><li><strong>输入</strong>：明文字符串和密钥字符串。</li><li><strong>初始化</strong>：创建一个空的加密字符串。</li><li><strong>遍历明文</strong>：<ul><li>对于每个字符，检查是否为字母。</li><li>如果是字母，计算密钥字符的偏移量（将密钥字符转换为小写字母，然后减去 ‘a’）。</li><li>根据偏移量对明文字符进行加密：<ul><li>如果是小写字母，使用公式 <code>(明文字符 - &#39;a&#39; + 偏移量) % 26 + &#39;a&#39;</code> 进行加密。</li><li>如果是大写字母，使用公式 <code>(明文字符 - &#39;A&#39; + 偏移量) % 26 + &#39;A&#39;</code> 进行加密。</li></ul></li><li>如果不是字母，直接将字符添加到加密字符串中。</li></ul></li><li><strong>输出</strong>：返回加密字符串。</li></ol><h3 id="3-解密过程"><a href="#3-解密过程" class="headerlink" title="3. 解密过程"></a>3. 解密过程</h3><ol><li><strong>输入</strong>：密文字符串和密钥字符串。</li><li><strong>初始化</strong>：创建一个空的解密字符串。</li><li><strong>遍历密文</strong>：<ul><li>对于每个字符，检查是否为字母。</li><li>如果是字母，计算密钥字符的偏移量（将密钥字符转换为小写字母，然后减去 ‘a’）。</li><li>根据偏移量对密文字符进行解密：<ul><li>如果是小写字母，使用公式 <code>(密文字符 - &#39;a&#39; - 偏移量 + 26) % 26 + &#39;a&#39;</code> 进行解密。</li><li>如果是大写字母，使用公式 <code>(密文字符 - &#39;A&#39; - 偏移量 + 26) % 26 + &#39;A&#39;</code> 进行解密。</li></ul></li><li>如果不是字母，直接将字符添加到解密字符串中。</li></ul></li><li><strong>输出</strong>：返回解密字符串。</li></ol><h3 id="4-代码实现"><a href="#4-代码实现" class="headerlink" title="4. 代码实现"></a>4. 代码实现</h3><p>以下是上述设计思路的代码实现：</p><p><code>VigenereCipher.h</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">pragma</span> once</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string&gt;</span></span><br><br><span class="hljs-keyword">namespace</span> sword&#123;<br>  <span class="hljs-keyword">namespace</span> util&#123;<br>    <span class="hljs-keyword">class</span> <span class="hljs-title class_">VigenereCipher</span> &#123;<br>      <span class="hljs-keyword">public</span>:<br>        <span class="hljs-built_in">VigenereCipher</span>(<span class="hljs-type">const</span> std::string&amp; key);<br><br>        <span class="hljs-function">std::string <span class="hljs-title">encrypt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; plaintext)</span></span>;<br>        <span class="hljs-function">std::string <span class="hljs-title">decrypt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; ciphertext)</span></span>;<br><br>      <span class="hljs-keyword">private</span>:<br>        std::string key;<br>    &#125;;<br>  &#125;<br>  <span class="hljs-keyword">using</span> util::VigenereCipher;<br>&#125;<br></code></pre></td></tr></table></figure><p><code>VigenereCipher.cpp</code></p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br></pre></td><td class="code"><pre><code class="hljs c++"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;VigenereCipher.h&quot;</span></span><br><br><span class="hljs-keyword">namespace</span> sword &#123;<br>  <span class="hljs-keyword">namespace</span> util &#123;<br>    <span class="hljs-comment">// 构造函数，初始化密钥</span><br>    VigenereCipher::<span class="hljs-built_in">VigenereCipher</span>(<span class="hljs-type">const</span> std::string&amp; key) : <span class="hljs-built_in">key</span>(key) &#123;&#125;<br><br>    <span class="hljs-comment">// 加密函数，接受明文并返回加密后的密文</span><br>    <span class="hljs-function">std::string <span class="hljs-title">VigenereCipher::encrypt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; plaintext)</span> </span>&#123;<br>      std::string encryptedText;<br>      <span class="hljs-type">int</span> keyLength = key.<span class="hljs-built_in">length</span>();<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; plaintext.<span class="hljs-built_in">length</span>(); ++i) &#123;<br>        <span class="hljs-type">char</span> charToEncrypt = plaintext[i];<br>        <span class="hljs-comment">// 判断字符是否为字母</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isalpha</span>(charToEncrypt)) &#123; <br>          <span class="hljs-comment">// 计算密钥字符的偏移量</span><br>          <span class="hljs-type">int</span> shift = <span class="hljs-built_in">tolower</span>(key[i % keyLength]) - <span class="hljs-string">&#x27;a&#x27;</span>; <br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">islower</span>(charToEncrypt)) &#123;<br>            <span class="hljs-comment">// 小写字母加密</span><br>            encryptedText += (charToEncrypt - <span class="hljs-string">&#x27;a&#x27;</span> + shift) % <span class="hljs-number">26</span> + <span class="hljs-string">&#x27;a&#x27;</span>;            <br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 大写字母加密</span><br>            encryptedText += (charToEncrypt - <span class="hljs-string">&#x27;A&#x27;</span> + shift) % <span class="hljs-number">26</span> + <span class="hljs-string">&#x27;A&#x27;</span>;           <br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 非字母字符不加密</span><br>          encryptedText += charToEncrypt; <br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> encryptedText;<br>    &#125;<br><br>    <span class="hljs-comment">// 解密函数，接受密文并返回解密后的明文</span><br>    <span class="hljs-function">std::string <span class="hljs-title">VigenereCipher::decrypt</span><span class="hljs-params">(<span class="hljs-type">const</span> std::string&amp; ciphertext)</span> </span>&#123;<br>      std::string decryptedText;<br>      <span class="hljs-type">int</span> keyLength = key.<span class="hljs-built_in">length</span>();<br>      <span class="hljs-keyword">for</span> (<span class="hljs-type">size_t</span> i = <span class="hljs-number">0</span>; i &lt; ciphertext.<span class="hljs-built_in">length</span>(); ++i) &#123;<br>        <span class="hljs-type">char</span> charToDecrypt = ciphertext[i];<br>        <span class="hljs-comment">// 判断字符是否为字母</span><br>        <span class="hljs-keyword">if</span> (<span class="hljs-built_in">isalpha</span>(charToDecrypt)) &#123; <br>          <span class="hljs-comment">// 计算密钥字符的偏移量</span><br>          <span class="hljs-type">int</span> shift = <span class="hljs-built_in">tolower</span>(key[i % keyLength]) - <span class="hljs-string">&#x27;a&#x27;</span>; <br>          <span class="hljs-keyword">if</span> (<span class="hljs-built_in">islower</span>(charToDecrypt)) &#123;<br>            <span class="hljs-comment">// 小写字母解密</span><br>            decryptedText += (charToDecrypt - <span class="hljs-string">&#x27;a&#x27;</span> - shift + <span class="hljs-number">26</span>) % <span class="hljs-number">26</span> + <span class="hljs-string">&#x27;a&#x27;</span>; <br>          &#125; <span class="hljs-keyword">else</span> &#123;<br>            <span class="hljs-comment">// 大写字母解密</span><br>            decryptedText += (charToDecrypt - <span class="hljs-string">&#x27;A&#x27;</span> - shift + <span class="hljs-number">26</span>) % <span class="hljs-number">26</span> + <span class="hljs-string">&#x27;A&#x27;</span>; <br>          &#125;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>          <span class="hljs-comment">// 非字母字符不解密</span><br>          decryptedText += charToDecrypt; <br>        &#125;<br>      &#125;<br>      <span class="hljs-keyword">return</span> decryptedText;<br>    &#125;<br>  &#125;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="实验步骤"><a href="#实验步骤" class="headerlink" title="实验步骤"></a>实验步骤</h3><ol><li><strong>定义密钥</strong>：使用密钥 <code>&quot;key&quot;</code>。</li><li><strong>创建 <code>VigenereCipher</code> 对象</strong>：使用上述密钥初始化 <code>VigenereCipher</code> 对象。</li><li><strong>定义明文</strong>：使用明文 <code>&quot;Hello, World!&quot;</code>。</li><li><strong>加密明文</strong>：调用 <code>encrypt</code> 方法对明文进行加密。</li><li><strong>解密密文</strong>：调用 <code>decrypt</code> 方法对加密后的密文进行解密。</li><li><strong>输出结果</strong>：打印明文、加密后的密文和解密后的明文。</li></ol><h3 id="实验结果"><a href="#实验结果" class="headerlink" title="实验结果"></a>实验结果</h3><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs plaintext">明文: Hello, World!<br>加密后: Rijvs, Uyvjn!<br>解密后: Hello, World!<br></code></pre></td></tr></table></figure><h3 id="结果分析"><a href="#结果分析" class="headerlink" title="结果分析"></a>结果分析</h3><ol><li><p><strong>加密结果</strong>：</p><ul><li>明文 <code>&quot;Hello, World!&quot;</code> 使用密钥 <code>&quot;key&quot;</code> 加密后得到密文 <code>&quot;Rijvs, Uyvjn!&quot;</code>。</li><li>可以看到，字母字符被正确加密，而非字母字符（如逗号和空格）保持不变。</li></ul></li><li><p><strong>解密结果</strong>：</p><ul><li>密文 <code>&quot;Rijvs, Uyvjn!&quot;</code> 使用相同的密钥 <code>&quot;key&quot;</code> 解密后恢复为原始明文 <code>&quot;Hello, World!&quot;</code>。</li><li>这表明加密和解密过程是对称的，能够正确还原原始明文。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>网络安全技术</category>
      
    </categories>
    
    
    <tags>
      
      <tag>网络安全技术</tag>
      
      <tag>加密算法</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell 命令替换</title>
    <link href="/2024/09/14/Shell%E5%91%BD%E4%BB%A4%E6%9B%BF%E6%8D%A2/"/>
    <url>/2024/09/14/Shell%E5%91%BD%E4%BB%A4%E6%9B%BF%E6%8D%A2/</url>
    
    <content type="html"><![CDATA[<h1 id="Shell-命令替换"><a href="#Shell-命令替换" class="headerlink" title="Shell 命令替换"></a>Shell 命令替换</h1><p>在 Shell 脚本中，命令替换是一种将命令的输出作为另一个命令的参数或变量值的方法。命令替换有两种语法：</p><ol><li>反引号（<code>`command`</code>）</li><li>$() 语法（<code>$(command)</code>）</li></ol><h2 id="反引号语法"><a href="#反引号语法" class="headerlink" title="反引号语法"></a>反引号语法</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">output=`<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello, World!&quot;</span>`<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$output</span><br></code></pre></td></tr></table></figure><h2 id="语法"><a href="#语法" class="headerlink" title="$() 语法"></a>$() 语法</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">output=$(<span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Hello, World!&quot;</span>)<br><span class="hljs-built_in">echo</span> <span class="hljs-variable">$output</span><br></code></pre></td></tr></table></figure><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>以下是一些使用命令替换的示例：</p><h3 id="示例-1：将命令输出赋值给变量"><a href="#示例-1：将命令输出赋值给变量" class="headerlink" title="示例 1：将命令输出赋值给变量"></a>示例 1：将命令输出赋值给变量</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">current_date=$(<span class="hljs-built_in">date</span>)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Current date and time: <span class="hljs-variable">$current_date</span>&quot;</span><br></code></pre></td></tr></table></figure><h3 id="示例-2：将命令输出作为另一个命令的参数"><a href="#示例-2：将命令输出作为另一个命令的参数" class="headerlink" title="示例 2：将命令输出作为另一个命令的参数"></a>示例 2：将命令输出作为另一个命令的参数</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">files=$(<span class="hljs-built_in">ls</span>)<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Files in the current directory: <span class="hljs-variable">$files</span>&quot;</span><br></code></pre></td></tr></table></figure><h3 id="示例-3：嵌套命令替换"><a href="#示例-3：嵌套命令替换" class="headerlink" title="示例 3：嵌套命令替换"></a>示例 3：嵌套命令替换</h3><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sh">nested_output=$(<span class="hljs-built_in">echo</span> $(<span class="hljs-built_in">date</span>))<br><span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;Nested command output: <span class="hljs-variable">$nested_output</span>&quot;</span><br></code></pre></td></tr></table></figure><h2 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h2><ul><li>使用 $() 语法比反引号语法更推荐，因为它更易读且支持嵌套。</li><li>命令替换会捕获命令的标准输出，但不会捕获标准错误输出。</li><li>如果命令输出包含换行符，可以使用 <code>IFS</code>（内部字段分隔符）来处理多行输出。</li></ul><h2 id="示例：处理多行输出"><a href="#示例：处理多行输出" class="headerlink" title="示例：处理多行输出"></a>示例：处理多行输出</h2><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh">output=$(<span class="hljs-built_in">ls</span>)<br>IFS=$<span class="hljs-string">&#x27;\n&#x27;</span> <span class="hljs-comment"># 设置内部字段分隔符为换行符</span><br><span class="hljs-keyword">for</span> file <span class="hljs-keyword">in</span> <span class="hljs-variable">$output</span>; <span class="hljs-keyword">do</span><br>    <span class="hljs-built_in">echo</span> <span class="hljs-string">&quot;File: <span class="hljs-variable">$file</span>&quot;</span><br><span class="hljs-keyword">done</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shell</tag>
      
      <tag>命令替换</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>在 main 函数之前执行一段代码</title>
    <link href="/2024/09/14/%E5%9C%A8%20main%20%E5%87%BD%E6%95%B0%E4%B9%8B%E5%89%8D%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81/"/>
    <url>/2024/09/14/%E5%9C%A8%20main%20%E5%87%BD%E6%95%B0%E4%B9%8B%E5%89%8D%E6%89%A7%E8%A1%8C%E4%B8%80%E6%AE%B5%E4%BB%A3%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="在-main-函数之前执行一段代码"><a href="#在-main-函数之前执行一段代码" class="headerlink" title="在 main 函数之前执行一段代码"></a>在 main 函数之前执行一段代码</h1><h2 id="方法1：构造全局对象"><a href="#方法1：构造全局对象" class="headerlink" title="方法1：构造全局对象"></a>方法1：构造全局对象</h2><p>你可以定义一个类，并在其构造函数中执行所需的代码。然后，创建该类的全局对象。由于全局对象在<code>main</code>函数之前初始化，因此其构造函数会在<code>main</code>函数之前执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Initializer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Initializer</span>() &#123;<br>        cout &lt;&lt; <span class="hljs-string">&quot;This runs before main()&quot;</span> &lt;&lt; endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-comment">// 创建全局对象</span><br>Initializer initializer;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;This runs in main()&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="方法2：使用-attribute-constructor-（GCC特定）"><a href="#方法2：使用-attribute-constructor-（GCC特定）" class="headerlink" title="方法2：使用__attribute__((constructor))（GCC特定）"></a>方法2：使用<code>__attribute__((constructor))</code>（GCC特定）</h2><p>在GCC编译器中，你可以使用<code>__attribute__((constructor))</code>属性来指定一个函数在<code>main</code>函数之前执行。</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">using</span> <span class="hljs-keyword">namespace</span> std;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">before_main</span><span class="hljs-params">()</span> __<span class="hljs-title">attribute__</span><span class="hljs-params">((constructor))</span></span>;<br><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">before_main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;This runs before main()&quot;</span> &lt;&lt; endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    cout &lt;&lt; <span class="hljs-string">&quot;This runs in main()&quot;</span> &lt;&lt; endl;<br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><ul><li><strong>方法1</strong>：全局对象的构造函数在<code>main</code>函数之前执行。</li><li><strong>方法2</strong>：<code>__attribute__((constructor))</code>属性指定的函数在<code>main</code>函数之前执行（仅适用于GCC）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Shell 命令 test</title>
    <link href="/2024/09/14/Shell%E5%91%BD%E4%BB%A4test/"/>
    <url>/2024/09/14/Shell%E5%91%BD%E4%BB%A4test/</url>
    
    <content type="html"><![CDATA[<h1 id="Shell-命令-test"><a href="#Shell-命令-test" class="headerlink" title="Shell 命令 test"></a>Shell 命令 test</h1><p><a href="command:_github.copilot.openRelativePath?%5B%7B%22scheme%22%3A%22file%22%2C%22authority%22%3A%22%22%2C%22path%22%3A%22%2Fe%3A%2FWorkSpace%2Flibgo%2Ftest%22%2C%22query%22%3A%22%22%2C%22fragment%22%3A%22%22%7D%2C%22026dc4a3-b688-49d7-a455-9f49d2152a56%22%5D" title="e:\WorkSpace\libgo\test"><code>test</code></a> 是一个常用的 Shell 内置命令，用于检查文件类型和比较值。它可以用于条件判断，通常与 <code>if</code> 语句结合使用。<a href="command:_github.copilot.openRelativePath?%5B%7B%22scheme%22%3A%22file%22%2C%22authority%22%3A%22%22%2C%22path%22%3A%22%2Fe%3A%2FWorkSpace%2Flibgo%2Ftest%22%2C%22query%22%3A%22%22%2C%22fragment%22%3A%22%22%7D%2C%22026dc4a3-b688-49d7-a455-9f49d2152a56%22%5D" title="e:\WorkSpace\libgo\test"><code>test</code></a> 命令也可以通过方括号 <code>[</code> 和 <code>]</code> 来表示，这种形式在 Shell 脚本中非常常见。</p><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">test EXPRESSION<br></code></pre></td></tr></table></figure><p>或</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs shell">[ EXPRESSION ]<br></code></pre></td></tr></table></figure><h3 id="常用表达式"><a href="#常用表达式" class="headerlink" title="常用表达式"></a>常用表达式</h3><h4 id="文件检查"><a href="#文件检查" class="headerlink" title="文件检查"></a>文件检查</h4><ul><li><code>-f FILE</code>：检查 FILE 是否存在且是一个普通文件。</li><li><code>-d FILE</code>：检查 FILE 是否存在且是一个目录。</li><li><code>-e FILE</code>：检查 FILE 是否存在。</li><li><code>-r FILE</code>：检查 FILE 是否存在且可读。</li><li><code>-w FILE</code>：检查 FILE 是否存在且可写。</li><li><code>-x FILE</code>：检查 FILE 是否存在且可执行。</li><li><code>-s FILE</code>：检查 FILE 是否存在且大小大于零。</li></ul><h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4><ul><li><code>-z STRING</code>：检查 STRING 是否为空（长度为零）。</li><li><code>-n STRING</code>：检查 STRING 是否非空（长度大于零）。</li><li><code>STRING1 = STRING2</code>：检查 STRING1 是否等于 STRING2。</li><li><code>STRING1 != STRING2</code>：检查 STRING1 是否不等于 STRING2。</li></ul><h4 id="数值比较"><a href="#数值比较" class="headerlink" title="数值比较"></a>数值比较</h4><ul><li><code>INTEGER1 -eq INTEGER2</code>：检查 INTEGER1 是否等于 INTEGER2。</li><li><code>INTEGER1 -ne INTEGER2</code>：检查 INTEGER1 是否不等于 INTEGER2。</li><li><code>INTEGER1 -gt INTEGER2</code>：检查 INTEGER1 是否大于 INTEGER2。</li><li><code>INTEGER1 -ge INTEGER2</code>：检查 INTEGER1 是否大于或等于 INTEGER2。</li><li><code>INTEGER1 -lt INTEGER2</code>：检查 INTEGER1 是否小于 INTEGER2。</li><li><code>INTEGER1 -le INTEGER2</code>：检查 INTEGER1 是否小于或等于 INTEGER2。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><h4 id="文件检查示例"><a href="#文件检查示例" class="headerlink" title="文件检查示例"></a>文件检查示例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查文件 b2 是否存在且是一个普通文件</span><br>if test -f b2; then<br>    echo &quot;File b2 exists and is a regular file.&quot;<br>else<br>    echo &quot;File b2 does not exist or is not a regular file.&quot;<br>fi<br></code></pre></td></tr></table></figure><p>或使用方括号表示法：</p><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查文件 b2 是否存在且是一个普通文件</span><br>if [ -f b2 ]; then<br>    echo &quot;File b2 exists and is a regular file.&quot;<br>else<br>    echo &quot;File b2 does not exist or is not a regular file.&quot;<br>fi<br></code></pre></td></tr></table></figure><h4 id="字符串比较示例"><a href="#字符串比较示例" class="headerlink" title="字符串比较示例"></a>字符串比较示例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>STRING1=&quot;hello&quot;<br>STRING2=&quot;world&quot;<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查字符串是否相等</span><br>if [ &quot;$STRING1&quot; = &quot;$STRING2&quot; ]; then<br>    echo &quot;Strings are equal.&quot;<br>else<br>    echo &quot;Strings are not equal.&quot;<br>fi<br></code></pre></td></tr></table></figure><h4 id="数值比较示例"><a href="#数值比较示例" class="headerlink" title="数值比较示例"></a>数值比较示例</h4><figure class="highlight shell"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs shell"><span class="hljs-meta prompt_">#</span><span class="language-bash">!/bin/bash</span><br><br>NUM1=5<br>NUM2=10<br><span class="hljs-meta prompt_"></span><br><span class="hljs-meta prompt_"># </span><span class="language-bash">检查数值大小</span><br>if [ $NUM1 -lt $NUM2 ]; then<br>    echo &quot;$NUM1 is less than $NUM2.&quot;<br>else<br>    echo &quot;$NUM1 is not less than $NUM2.&quot;<br>fi<br></code></pre></td></tr></table></figure><h3 id="解释"><a href="#解释" class="headerlink" title="解释"></a>解释</h3><ol><li><p><strong>文件检查</strong>：</p><ul><li><code>test -f b2</code> 或 <code>[ -f b2 ]</code>：检查文件 <a href="command:_github.copilot.openSymbolFromReferences?%5B%22%22%2C%5B%7B%22uri%22%3A%7B%22scheme%22%3A%22file%22%2C%22authority%22%3A%22%22%2C%22path%22%3A%22%2Fe%3A%2FWorkSpace%2Flibgo%2Fthird_party%2Fselect_asm.sh%22%2C%22query%22%3A%22%22%2C%22fragment%22%3A%22%22%7D%2C%22pos%22%3A%7B%22line%22%3A5%2C%22character%22%3A8%7D%7D%5D%2C%22026dc4a3-b688-49d7-a455-9f49d2152a56%22%5D" title="Go to definition"><code>b2</code></a> 是否存在且是一个普通文件。</li><li>如果条件为真，执行 <code>then</code> 部分的代码；否则，执行 <code>else</code> 部分的代码。</li></ul></li><li><p><strong>字符串比较</strong>：</p><ul><li><code>[ &quot;$STRING1&quot; = &quot;$STRING2&quot; ]</code>：检查字符串 <code>STRING1</code> 是否等于 <code>STRING2</code>。</li><li>如果条件为真，输出 <code>Strings are equal.</code>；否则，输出 <code>Strings are not equal.</code>。</li></ul></li><li><p><strong>数值比较</strong>：</p><ul><li><code>[ $NUM1 -lt $NUM2 ]</code>：检查数值 <code>NUM1</code> 是否小于 <code>NUM2</code>。</li><li>如果条件为真，输出 <code>$NUM1 is less than $NUM2.</code>；否则，输出 <code>$NUM1 is not less than $NUM2.</code>。</li></ul></li></ol>]]></content>
    
    
    <categories>
      
      <category>Shell</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Shell</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>使用 CMake 进行文件配置</title>
    <link href="/2024/09/14/CMake%E7%94%9F%E6%88%90%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/"/>
    <url>/2024/09/14/CMake%E7%94%9F%E6%88%90%E9%85%8D%E7%BD%AE%E6%96%87%E4%BB%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="使用-CMake-进行文件配置"><a href="#使用-CMake-进行文件配置" class="headerlink" title="使用 CMake 进行文件配置"></a>使用 CMake 进行文件配置</h1><h2 id="预备知识"><a href="#预备知识" class="headerlink" title="预备知识"></a>预备知识</h2><h3 id="configure-file-命令"><a href="#configure-file-命令" class="headerlink" title="configure_file 命令"></a>configure_file 命令</h3><p><code>configure_file</code> 命令是 CMake 中用于处理配置文件的命令。它可以将模板文件中的占位符替换为实际的值，并生成一个新的配置文件。这个命令通常用于生成头文件或其他配置文件，以便在构建过程中使用。</p><p> 语法</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">configure_file</span>(&lt;input&gt; &lt;output&gt; [COPYONLY] [ESCAPE_QUOTES] [@ONLY])<br></code></pre></td></tr></table></figure><ul><li><code>&lt;input&gt;</code>：输入模板文件的路径。</li><li><code>&lt;output&gt;</code>：输出配置文件的路径。</li><li><code>COPYONLY</code>：仅复制文件，不进行任何替换。</li><li><code>ESCAPE_QUOTES</code>：在替换过程中转义双引号。</li><li><code>@ONLY</code>：仅替换 <code>@VAR@</code> 形式的占位符，而不替换 <code>$&#123;VAR&#125;</code> 形式的占位符。</li></ul><h3 id="CMake-符号-和"><a href="#CMake-符号-和" class="headerlink" title="CMake 符号 $ 和 @"></a>CMake 符号 $ 和 @</h3><p>在 CMake 中，<code>$</code> 和 <code>@</code> 都用于变量替换，但它们的使用场景和方式有所不同。</p><h4 id="符号"><a href="#符号" class="headerlink" title="$ 符号"></a><code>$</code> 符号</h4><p><code>$</code> 符号用于引用 CMake 变量。CMake 变量的引用形式为 <code>$&#123;VAR_NAME&#125;</code>，其中 <code>VAR_NAME</code> 是变量的名称。</p><h5 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h5><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">set</span>(PROJECT_NAME <span class="hljs-string">&quot;MyProject&quot;</span>)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;Project Name: $&#123;PROJECT_NAME&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>set</code> 命令定义了一个名为 <code>PROJECT_NAME</code> 的变量，其值为 <code>&quot;MyProject&quot;</code>。<code>message</code> 命令会输出 <code>Project Name: MyProject</code>。</p><h4 id="符号-1"><a href="#符号-1" class="headerlink" title="@ 符号"></a><code>@</code> 符号</h4><p><code>@</code> 符号通常用于 <code>configure_file</code> 命令中的模板文件，占位符的形式为 <code>@VAR_NAME@</code>。在使用 <code>configure_file</code> 命令生成配置文件时，CMake 会将模板文件中的 <code>@VAR_NAME@</code> 替换为相应的变量值。</p><h3 id="cmakedefine-命令"><a href="#cmakedefine-命令" class="headerlink" title="#cmakedefine 命令"></a>#cmakedefine 命令</h3><p><code>#cmakedefine</code> 是 CMake 中用于在配置文件模板中定义条件编译宏的指令。它通常与 <code>configure_file</code> 命令一起使用，以根据 CMake 配置选项生成最终的配置头文件。</p><h4 id="基本用法"><a href="#基本用法" class="headerlink" title="基本用法"></a>基本用法</h4><p><code>#cmakedefine</code> 的基本语法如下：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-comment">#cmakedefine VAR</span><br><span class="hljs-comment">#cmakedefine VAR VALUE</span><br></code></pre></td></tr></table></figure><ul><li><code>VAR</code> 是要定义的变量名。</li><li><code>VALUE</code> 是可选的值，如果未提供，默认值为 <code>1</code>。</li><li>只有当 <code>CMakeLists.txt</code> 中的同名变量为真时才会在生成的头文件中定义，区别于#define无论何时都会定义。</li></ul><h2 id="基本步骤"><a href="#基本步骤" class="headerlink" title="基本步骤"></a>基本步骤</h2><p>使用 CMake 进行文件配置通常涉及以下几个步骤：定义模板文件、配置选项、生成配置文件，并在代码中使用生成的配置文件。</p><ol><li><strong>定义模板文件</strong>：创建一个模板文件，其中包含需要配置的占位符和条件编译指令。</li><li><strong>配置选项</strong>：在 <a href="command:_github.copilot.openRelativePath?%5B%7B%22scheme%22%3A%22file%22%2C%22authority%22%3A%22%22%2C%22path%22%3A%22%2Fe%3A%2FWorkSpace%2Flibgo%2FCMakeLists.txt%22%2C%22query%22%3A%22%22%2C%22fragment%22%3A%22%22%7D%2C%225b3f5a37-0226-4ca9-be03-9052607f1f8f%22%5D" title="e:\WorkSpace\libgo\CMakeLists.txt"><code>CMakeLists.txt</code></a> 文件中使用 <a href="command:_github.copilot.openSymbolFromReferences?%5B%22%22%2C%5B%7B%22uri%22%3A%7B%22scheme%22%3A%22file%22%2C%22authority%22%3A%22%22%2C%22path%22%3A%22%2FE%3A%2FWorkSpace%2Flibgo%2FCMakeLists.txt%22%2C%22query%22%3A%22%22%2C%22fragment%22%3A%22%22%7D%2C%22pos%22%3A%7B%22line%22%3A17%2C%22character%22%3A0%7D%7D%5D%2C%227d490db7-b09a-4e43-bc82-a37a80157136%22%5D" title="Go to definition"><code>option</code></a> 命令定义布尔选项。</li><li><strong>生成配置文件</strong>：使用 <code>configure_file</code> 命令生成最终的配置文件，CMake 会根据配置选项替换模板文件中的占位符和条件编译指令。</li><li><strong>在代码中使用生成的配置文件</strong>：在需要使用配置的源文件中包含生成的配置文件。</li></ol><h3 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h3><p>以下是一个完整的示例，展示了如何使用 CMake 进行文件配置。</p><h3 id="目录结构"><a href="#目录结构" class="headerlink" title="目录结构"></a>目录结构</h3><figure class="highlight stylus"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs stylus">ConfigProject/<br>├── CMakeLists<span class="hljs-selector-class">.txt</span><br>├── cmake_config<span class="hljs-selector-class">.h</span><span class="hljs-selector-class">.in</span><br>└── <span class="hljs-selector-tag">main</span>.cpp<br></code></pre></td></tr></table></figure><h3 id="cmake-config-h-in"><a href="#cmake-config-h-in" class="headerlink" title="cmake_config.h.in"></a><a href="command:_github.copilot.openRelativePath?%5B%7B%22scheme%22%3A%22file%22%2C%22authority%22%3A%22%22%2C%22path%22%3A%22%2Fe%3A%2FWorkSpace%2Flibgo%2Fcmake_config.h.in%22%2C%22query%22%3A%22%22%2C%22fragment%22%3A%22%22%7D%2C%22d5e0c5b4-7b5d-4b4e-8b5b-1b5d7b5d7b5d%22%5D" title="e:\WorkSpace\libgo\cmake_config.h.in"><code>cmake_config.h.in</code></a></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义项目名称</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PROJECT_NAME <span class="hljs-string">&quot;$&#123;PROJECT_NAME&#125;&quot;</span></span><br><br><span class="hljs-comment">// 定义项目版本</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PROJECT_VERSION <span class="hljs-string">&quot;$&#123;PROJECT_VERSION&#125;&quot;</span></span><br><br><span class="hljs-comment">// 定义是否启用特定功能</span><br><span class="hljs-meta">#cmakedefine ENABLE_FEATURE $&#123;ENABLE_FEATURE&#125;</span><br></code></pre></td></tr></table></figure><h3 id="CMakeLists-txt"><a href="#CMakeLists-txt" class="headerlink" title="CMakeLists.txt"></a><a href="command:_github.copilot.openRelativePath?%5B%7B%22scheme%22%3A%22file%22%2C%22authority%22%3A%22%22%2C%22path%22%3A%22%2Fe%3A%2FWorkSpace%2Flibgo%2FCMakeLists.txt%22%2C%22query%22%3A%22%22%2C%22fragment%22%3A%22%22%7D%2C%225b3f5a37-0226-4ca9-be03-9052607f1f8f%22%5D" title="e:\WorkSpace\libgo\CMakeLists.txt"><code>CMakeLists.txt</code></a></h3><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.15</span>)<br><br><span class="hljs-comment"># 项目名称和版本</span><br><span class="hljs-keyword">project</span>(ConfigProject VERSION <span class="hljs-number">1.0</span>)<br><br><span class="hljs-comment"># 设置C++标准</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">11</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">True</span>)<br><br><span class="hljs-comment"># 配置选项</span><br><span class="hljs-keyword">option</span>(ENABLE_FEATURE <span class="hljs-string">&quot;Enable feature&quot;</span> <span class="hljs-keyword">OFF</span>)<br><br><span class="hljs-comment"># 生成配置文件</span><br><span class="hljs-keyword">configure_file</span>(cmake_config.h.in <span class="hljs-variable">$&#123;CMAKE_BINARY_DIR&#125;</span>/cmake_config.h)<br><br><span class="hljs-comment"># 包含生成的配置文件目录</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;CMAKE_BINARY_DIR&#125;</span>)<br><br><span class="hljs-comment"># 添加可执行文件</span><br><span class="hljs-keyword">add_executable</span>(config_project main.cpp)<br></code></pre></td></tr></table></figure><h3 id="main-cpp"><a href="#main-cpp" class="headerlink" title="main.cpp"></a><code>main.cpp</code></h3><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&quot;cmake_config.h&quot;</span></span><br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span></span>&#123;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Project Name: &quot;</span> &lt;&lt; PROJECT_NAME &lt;&lt; std::endl;<br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Project Version: &quot;</span> &lt;&lt; PROJECT_VERSION &lt;&lt; std::endl;<br><br><span class="hljs-meta">#<span class="hljs-keyword">ifdef</span> ENABLE_FEATURE</span><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Feature Enabled&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-meta">#<span class="hljs-keyword">else</span></span><br>  std::cout &lt;&lt; <span class="hljs-string">&quot;Feature Disabled&quot;</span> &lt;&lt; std::endl;<br><span class="hljs-meta">#<span class="hljs-keyword">endif</span></span><br><br>  <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="启用选项的结果"><a href="#启用选项的结果" class="headerlink" title="启用选项的结果"></a>启用选项的结果</h3><p>假设我们在配置项目时启用了 <code>ENABLE_FEATURE</code>  选项：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">cmake -DENABLE_FEATURE=ON ..<br></code></pre></td></tr></table></figure><p>在这种情况下，生成的 <code>config.h</code> 文件将如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义项目名称</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PROJECT_NAME <span class="hljs-string">&quot;ConfigProject&quot;</span></span><br><br><span class="hljs-comment">// 定义项目版本</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PROJECT_VERSION <span class="hljs-string">&quot;1.0&quot;</span></span><br><br><span class="hljs-comment">// 定义是否启用特定功能</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> ENABLE_FEATURE ON</span><br></code></pre></td></tr></table></figure><h3 id="未启用选项的结果"><a href="#未启用选项的结果" class="headerlink" title="未启用选项的结果"></a>未启用选项的结果</h3><p>假设我们在配置项目时未启用 <code>ENABLE_FEATURE</code>  选项：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs sh">cmake -DENABLE_FEATURE=OFF ..<br></code></pre></td></tr></table></figure><p>在这种情况下，生成的 <code>config.h</code> 文件将如下所示：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">// 定义项目名称</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PROJECT_NAME <span class="hljs-string">&quot;ConfigProject&quot;</span></span><br><br><span class="hljs-comment">// 定义项目版本</span><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> PROJECT_VERSION <span class="hljs-string">&quot;1.0&quot;</span></span><br><br><span class="hljs-comment">// 定义是否启用特定功能</span><br><span class="hljs-comment">/* #undef ENABLE_FEATURE */</span><br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CMake</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 枚举类型</title>
    <link href="/2024/09/13/C++%20%E6%9E%9A%E4%B8%BE/"/>
    <url>/2024/09/13/C++%20%E6%9E%9A%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="C-枚举类型"><a href="#C-枚举类型" class="headerlink" title="C++ 枚举类型"></a>C++ 枚举类型</h1><p>在C++中，枚举（enum）是一种用户定义的类型，用于表示一组命名的常量。C++11引入了强类型枚举（enum class），提供了更强的类型安全性和作用域控制。以下是对传统枚举（enum）和强类型枚举（enum class）的详细总结。</p><h3 id="1-传统枚举（enum）"><a href="#1-传统枚举（enum）" class="headerlink" title="1. 传统枚举（enum）"></a>1. 传统枚举（enum）</h3><p>传统枚举是C++中最早引入的一种枚举类型，定义在全局作用域或类作用域中。传统枚举的枚举值是整型常量，可以隐式转换为整数类型。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    Red,<br>    Green,<br>    Blue<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Color color = Red;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Color: &quot;</span> &lt;&lt; color &lt;&lt; std::endl; <span class="hljs-comment">// 输出：Color: 0</span><br><br>    <span class="hljs-comment">// 隐式转换为整数</span><br>    <span class="hljs-type">int</span> colorValue = color;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Color value: &quot;</span> &lt;&lt; colorValue &lt;&lt; std::endl; <span class="hljs-comment">// 输出：Color value: 0</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>隐式转换</strong>：枚举值可以隐式转换为整数类型。</li><li><strong>作用域</strong>：枚举值在定义的作用域内是全局的，可能会导致命名冲突。</li><li><strong>类型安全性</strong>：较低，枚举值可以隐式转换为整数，容易引发错误。</li></ul><h3 id="2-强类型枚举（enum-class）"><a href="#2-强类型枚举（enum-class）" class="headerlink" title="2. 强类型枚举（enum class）"></a>2. 强类型枚举（enum class）</h3><p>C++11引入了强类型枚举（enum class），提供了更强的类型安全性和作用域控制。强类型枚举的枚举值不能隐式转换为整数类型，必须显式转换。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span> &#123;<br>    Red,<br>    Green,<br>    Blue<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Color color = Color::Red;<br>    <span class="hljs-comment">// std::cout &lt;&lt; &quot;Color: &quot; &lt;&lt; color &lt;&lt; std::endl; // 错误：不能隐式转换为整数</span><br><br>    <span class="hljs-comment">// 显式转换为整数</span><br>    <span class="hljs-type">int</span> colorValue = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(color);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Color value: &quot;</span> &lt;&lt; colorValue &lt;&lt; std::endl; <span class="hljs-comment">// 输出：Color value: 0</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>显式转换</strong>：枚举值不能隐式转换为整数类型，必须显式转换。</li><li><strong>作用域</strong>：枚举值在定义的作用域内是局部的，避免了命名冲突。</li><li><strong>类型安全性</strong>：更高，枚举值不能隐式转换为整数，减少了错误的可能性。</li></ul><h3 id="3-枚举的定义和使用"><a href="#3-枚举的定义和使用" class="headerlink" title="3. 枚举的定义和使用"></a>3. 枚举的定义和使用</h3><h4 id="传统枚举的定义和使用"><a href="#传统枚举的定义和使用" class="headerlink" title="传统枚举的定义和使用"></a>传统枚举的定义和使用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    Red,<br>    Green,<br>    Blue<br>&#125;;<br><br>Color color = Red;<br></code></pre></td></tr></table></figure><h4 id="强类型枚举的定义和使用"><a href="#强类型枚举的定义和使用" class="headerlink" title="强类型枚举的定义和使用"></a>强类型枚举的定义和使用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span> &#123;<br>    Red,<br>    Green,<br>    Blue<br>&#125;;<br><br>Color color = Color::Red;<br></code></pre></td></tr></table></figure><h3 id="4-枚举的底层类型"><a href="#4-枚举的底层类型" class="headerlink" title="4. 枚举的底层类型"></a>4. 枚举的底层类型</h3><p>在C++11及其后续版本中，可以指定枚举的底层类型。默认情况下，底层类型是 <code>int</code>。</p><h4 id="示例：指定底层类型"><a href="#示例：指定底层类型" class="headerlink" title="示例：指定底层类型"></a>示例：指定底层类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span> : <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> &#123;<br>    Red,<br>    Green,<br>    Blue<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Color color = Color::Red;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> colorValue = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;(color);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Color value: &quot;</span> &lt;&lt; colorValue &lt;&lt; std::endl; <span class="hljs-comment">// 输出：Color value: 0</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-枚举的比较"><a href="#5-枚举的比较" class="headerlink" title="5. 枚举的比较"></a>5. 枚举的比较</h3><p>枚举值可以进行比较操作，如相等性比较和关系比较。</p><h4 id="示例：枚举的比较"><a href="#示例：枚举的比较" class="headerlink" title="示例：枚举的比较"></a>示例：枚举的比较</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span> &#123;<br>    Red,<br>    Green,<br>    Blue<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Color color1 = Color::Red;<br>    Color color2 = Color::Green;<br><br>    <span class="hljs-keyword">if</span> (color1 == Color::Red) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;color1 is Red&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (color1 != color2) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;color1 is not equal to color2&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p><strong>传统枚举（enum）</strong>：</p><ul><li><strong>隐式转换</strong>：枚举值可以隐式转换为整数类型。</li><li><strong>作用域</strong>：枚举值在定义的作用域内是全局的，可能会导致命名冲突。</li><li><strong>类型安全性</strong>：较低，枚举值可以隐式转换为整数，容易引发错误。</li></ul></li><li><p><strong>强类型枚举（enum class）</strong>：</p><ul><li><strong>显式转换</strong>：枚举值不能隐式转换为整数类型，必须显式转换。</li><li><strong>作用域</strong>：枚举值在定义的作用域内是局部的，避免了命名冲突。</li><li><strong>类型安全性</strong>：更高，枚举值不能隐式转换为整数，减少了错误的可能性。</li><li><strong>底层类型</strong>：可以指定枚举的底层类型。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>枚举类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake 常见路径变量和命令总结</title>
    <link href="/2024/09/12/CMake%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/"/>
    <url>/2024/09/12/CMake%E5%9F%BA%E6%9C%AC%E5%91%BD%E4%BB%A4/</url>
    
    <content type="html"><![CDATA[<h2 id="CMake-常见路径变量和命令总结"><a href="#CMake-常见路径变量和命令总结" class="headerlink" title="CMake 常见路径变量和命令总结"></a>CMake 常见路径变量和命令总结</h2><h3 id="常用路径变量"><a href="#常用路径变量" class="headerlink" title="常用路径变量"></a>常用路径变量</h3><ol><li>**<code>CMAKE_SOURCE_DIR</code>**：项目的根目录，即包含顶层 <a href="command:_github.copilot.openRelativePath?%5B%7B%22scheme%22%3A%22file%22%2C%22authority%22%3A%22%22%2C%22path%22%3A%22%2Fe%3A%2FWorkSpace%2Fmuduo%2FCMakeLists.txt%22%2C%22query%22%3A%22%22%2C%22fragment%22%3A%22%22%7D%5D" title="e:\WorkSpace\muduo\CMakeLists.txt"><code>CMakeLists.txt</code></a> 文件的目录。</li><li>**<code>CMAKE_BINARY_DIR</code>**：构建目录，即运行 <a href="command:_github.copilot.openRelativePath?%5B%7B%22scheme%22%3A%22file%22%2C%22authority%22%3A%22%22%2C%22path%22%3A%22%2Fe%3A%2FWorkSpace%2Fmuduo%2Fcmake%22%2C%22query%22%3A%22%22%2C%22fragment%22%3A%22%22%7D%5D" title="e:\WorkSpace\muduo\cmake"><code>cmake</code></a> 命令的目录。</li><li>**<code>PROJECT_SOURCE_DIR</code>**：当前项目的源代码目录。</li><li>**<code>PROJECT_BINARY_DIR</code>**：当前项目的构建目录。</li><li>**<code>CMAKE_CURRENT_SOURCE_DIR</code>**：当前处理的 <a href="command:_github.copilot.openRelativePath?%5B%7B%22scheme%22%3A%22file%22%2C%22authority%22%3A%22%22%2C%22path%22%3A%22%2Fe%3A%2FWorkSpace%2Fmuduo%2FCMakeLists.txt%22%2C%22query%22%3A%22%22%2C%22fragment%22%3A%22%22%7D%5D" title="e:\WorkSpace\muduo\CMakeLists.txt"><code>CMakeLists.txt</code></a> 文件所在的目录。</li><li>**<code>CMAKE_CURRENT_BINARY_DIR</code>**：当前处理的 <a href="command:_github.copilot.openRelativePath?%5B%7B%22scheme%22%3A%22file%22%2C%22authority%22%3A%22%22%2C%22path%22%3A%22%2Fe%3A%2FWorkSpace%2Fmuduo%2FCMakeLists.txt%22%2C%22query%22%3A%22%22%2C%22fragment%22%3A%22%22%7D%5D" title="e:\WorkSpace\muduo\CMakeLists.txt"><code>CMakeLists.txt</code></a> 文件的构建目录。</li><li>**<code>CMAKE_INSTALL_PREFIX</code>**：安装路径前缀，默认是 <code>/usr/local</code>。</li></ol><h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3><ol><li>**<code>include_directories</code>**：添加头文件搜索路径。</li><li>**<code>link_directories</code>**：添加库文件搜索路径。</li><li>**<code>add_executable</code>**：添加可执行文件。</li><li>**<code>add_library</code>**：添加库文件。</li><li>**<code>target_include_directories</code>**：为目标添加头文件搜索路径。</li><li>**<code>target_link_libraries</code>**：为目标添加链接库。</li></ol><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>假设你的项目结构如下：</p><figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs gradle"><span class="hljs-regexp">/path/</span>to<span class="hljs-regexp">/your/</span><span class="hljs-keyword">project</span><br>├── CMakeLists.txt<br>├── <span class="hljs-keyword">include</span><br>│   └── noncopyable.h<br>└── test<br>    └── test_noncopyable.cpp<br></code></pre></td></tr></table></figure><p>可以在 <a href="command:_github.copilot.openRelativePath?%5B%7B%22scheme%22%3A%22file%22%2C%22authority%22%3A%22%22%2C%22path%22%3A%22%2Fe%3A%2FWorkSpace%2Fmuduo%2FCMakeLists.txt%22%2C%22query%22%3A%22%22%2C%22fragment%22%3A%22%22%7D%5D" title="e:\WorkSpace\muduo\CMakeLists.txt"><code>CMakeLists.txt</code></a> 文件中使用这些路径变量和命令：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.10</span>)<br><span class="hljs-keyword">project</span>(MuduoBase)<br><br><span class="hljs-comment"># 设置 C++ 标准</span><br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD <span class="hljs-number">11</span>)<br><span class="hljs-keyword">set</span>(CMAKE_CXX_STANDARD_REQUIRED <span class="hljs-keyword">True</span>)<br><br><span class="hljs-comment"># 添加头文件搜索路径</span><br><span class="hljs-keyword">include_directories</span>(<span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><br><span class="hljs-comment"># 添加 INTERFACE 库</span><br><span class="hljs-keyword">add_library</span>(muduo_base INTERFACE)<br><span class="hljs-keyword">target_include_directories</span>(muduo_base INTERFACE <span class="hljs-variable">$&#123;PROJECT_SOURCE_DIR&#125;</span>/<span class="hljs-keyword">include</span>)<br><br><span class="hljs-comment"># 启用测试</span><br><span class="hljs-keyword">enable_testing</span>()<br><br><span class="hljs-comment"># 添加测试可执行文件</span><br><span class="hljs-keyword">add_executable</span>(test_noncopyable <span class="hljs-keyword">test</span>/test_noncopyable.cpp)<br><br><span class="hljs-comment"># 链接 INTERFACE 库</span><br><span class="hljs-keyword">target_link_libraries</span>(test_noncopyable muduo_base)<br><br><span class="hljs-comment"># 添加测试</span><br><span class="hljs-keyword">add_test</span>(NAME TestNoncopyable <span class="hljs-keyword">COMMAND</span> test_noncopyable)<br></code></pre></td></tr></table></figure><h3 id="生成和运行测试"><a href="#生成和运行测试" class="headerlink" title="生成和运行测试"></a>生成和运行测试</h3><p>在项目根目录中运行以下命令生成和运行测试：</p><figure class="highlight sh"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs sh"><span class="hljs-built_in">mkdir</span> build<br><span class="hljs-built_in">cd</span> build<br>cmake ..<br>make<br>ctest<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>CMake</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之设计原则</title>
    <link href="/2024/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <url>/2024/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="C-设计模式之设计原则"><a href="#C-设计模式之设计原则" class="headerlink" title="C++ 设计模式之设计原则"></a>C++ 设计模式之设计原则</h1><p>设计模式中的设计原则是指导软件设计的基本准则，旨在提高代码的可维护性、可扩展性和灵活性。这些原则帮助开发者编写出更健壮、更易于理解和更易于修改的代码。以下是一些关键的设计原则及其总结：</p><h3 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1. 单一职责原则"></a>1. 单一职责原则</h3><p><strong>原则</strong>：一个类应该只有一个引起变化的原因，即一个类只负责一个职责。</p><p><strong>优点</strong>：</p><ul><li>提高类的内聚性。</li><li>降低类的复杂度。</li><li>提高代码的可维护性和可读性。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReportGenerator</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">generateReport</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 生成报告的逻辑</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReportPrinter</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printReport</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 打印报告的逻辑</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-开放封闭原则"><a href="#2-开放封闭原则" class="headerlink" title="2. 开放封闭原则"></a>2. 开放封闭原则</h3><p><strong>原则</strong>：软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。</p><p><strong>优点</strong>：</p><ul><li>提高代码的可扩展性。</li><li>降低代码的修改风险。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Shape</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 绘制圆形</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 绘制矩形</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-里氏替换原则"><a href="#3-里氏替换原则" class="headerlink" title="3. 里氏替换原则"></a>3. 里氏替换原则</h3><p><strong>原则</strong>：派生类对象应该能够替换基类对象而不影响程序的正确性。</p><p><strong>优点</strong>：</p><ul><li>保证继承关系的正确性。</li><li>提高代码的可替换性和可扩展性。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// 鸟类飞行的逻辑</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sparrow</span> : <span class="hljs-keyword">public</span> Bird &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 麻雀飞行的逻辑</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-接口隔离原则"><a href="#4-接口隔离原则" class="headerlink" title="4. 接口隔离原则"></a>4. 接口隔离原则</h3><p><strong>原则</strong>：一个类不应该依赖于它不使用的接口。应将接口拆分为更小、更专注的接口。</p><p><strong>优点</strong>：</p><ul><li>提高接口的内聚性。</li><li>降低类的复杂度和耦合度。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Printer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Printer</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Scanner</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">scan</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Scanner</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiFunctionPrinter</span> : <span class="hljs-keyword">public</span> Printer, <span class="hljs-keyword">public</span> Scanner &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 打印逻辑</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">scan</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 扫描逻辑</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-依赖倒置原则"><a href="#5-依赖倒置原则" class="headerlink" title="5. 依赖倒置原则"></a>5. 依赖倒置原则</h3><p><strong>原则</strong>：高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p><p><strong>优点</strong>：</p><ul><li>提高代码的灵活性和可扩展性。</li><li>降低模块之间的耦合度。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IWorker</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">IWorker</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> : <span class="hljs-keyword">public</span> IWorker &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 工作逻辑</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Manager</span>(IWorker* worker) : <span class="hljs-built_in">worker_</span>(worker) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">manage</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        worker_-&gt;<span class="hljs-built_in">work</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    IWorker* worker_;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="设计模式中的设计原则总结"><a href="#设计模式中的设计原则总结" class="headerlink" title="设计模式中的设计原则总结"></a>设计模式中的设计原则总结</h3><ol><li><strong>单一职责原则（SRP）</strong>：一个类只负责一个职责。</li><li><strong>开放封闭原则（OCP）</strong>：软件实体应该对扩展开放，对修改封闭。</li><li><strong>里氏替换原则（LSP）</strong>：派生类对象应该能够替换基类对象而不影响程序的正确性。</li><li><strong>接口隔离原则（ISP）</strong>：一个类不应该依赖于它不使用的接口。</li><li><strong>依赖倒置原则（DIP）</strong>：高层模块不应该依赖于低层模块，二者都应该依赖于抽象。</li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>设计模式</tag>
      
      <tag>设计原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 定位 new</title>
    <link href="/2024/09/05/C++%20%E5%AE%9A%E4%BD%8Dnew/"/>
    <url>/2024/09/05/C++%20%E5%AE%9A%E4%BD%8Dnew/</url>
    
    <content type="html"><![CDATA[<h1 id="C-定位-new"><a href="#C-定位-new" class="headerlink" title="C++ 定位 new"></a>C++ 定位 new</h1><p>定位 <code>new</code>（placement new） 是 C++ 中的一种特殊的 <code>new</code> 运算符，用于在指定的内存地址上构造对象。它允许开发者在预先分配的内存区域中构造对象，而不是从堆中分配新的内存。这在需要精确控制内存布局或在预先分配的内存中构造对象的场景中非常有用。</p><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul><li><strong>在指定内存地址上构造对象</strong>：定位 <code>new</code> 允许在预先分配的内存区域中构造对象。</li><li><strong>避免额外的内存分配</strong>：通过在已有的内存区域中构造对象，可以避免额外的内存分配开销。</li><li><strong>精确控制内存布局</strong>：适用于需要精确控制对象在内存中布局的场景。</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>定位 <code>new</code> 的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">new</span> (address) <span class="hljs-built_in">Type</span>(arguments);<br></code></pre></td></tr></table></figure><ul><li><code>address</code>：指定的内存地址，通常是一个 <code>void*</code> 指针。</li><li><code>Type</code>：要构造的对象的类型。</li><li><code>arguments</code>：构造函数的参数列表。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下是一些使用定位 <code>new</code> 的示例，展示了如何在指定的内存地址上构造对象。</p><h4 id="示例-1：基本使用"><a href="#示例-1：基本使用" class="headerlink" title="示例 1：基本使用"></a>示例 1：基本使用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span> <span class="hljs-comment">// for placement new</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> value) : <span class="hljs-built_in">value_</span>(value) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass constructor: &quot;</span> &lt;&lt; value_ &lt;&lt; std::endl;<br>    &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destructor: &quot;</span> &lt;&lt; value_ &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value_ &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 分配足够的内存来存储一个 MyClass 对象</span><br>    <span class="hljs-type">void</span>* memory = <span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-built_in">sizeof</span>(MyClass));<br><br>    <span class="hljs-comment">// 在指定的内存地址上构造 MyClass 对象</span><br>    MyClass* obj = <span class="hljs-built_in">new</span> (memory) <span class="hljs-built_in">MyClass</span>(<span class="hljs-number">42</span>);<br><br>    <span class="hljs-comment">// 使用对象</span><br>    obj-&gt;<span class="hljs-built_in">display</span>();<br><br>    <span class="hljs-comment">// 手动调用析构函数</span><br>    obj-&gt;~<span class="hljs-built_in">MyClass</span>();<br><br>    <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(memory)</span></span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="示例-2：在数组中使用定位-new"><a href="#示例-2：在数组中使用定位-new" class="headerlink" title="示例 2：在数组中使用定位 new"></a>示例 2：在数组中使用定位 <code>new</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span> <span class="hljs-comment">// for placement new</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> value) : <span class="hljs-built_in">value_</span>(value) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass constructor: &quot;</span> &lt;&lt; value_ &lt;&lt; std::endl; <br> &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destructor: &quot;</span> &lt;&lt; value_ &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value_ &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> arraySize = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-comment">// 分配足够的内存来存储一个 MyClass 对象数组</span><br>    <span class="hljs-type">void</span>* memory = <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](arraySize * <span class="hljs-built_in">sizeof</span>(MyClass));<br><br>    <span class="hljs-comment">// 在指定的内存地址上构造 MyClass 对象数组</span><br>    MyClass* objArray = <span class="hljs-built_in">static_cast</span>&lt;MyClass*&gt;(memory);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arraySize; ++i) &#123;<br>        <span class="hljs-keyword">new</span> (&amp;objArray[i]) <span class="hljs-built_in">MyClass</span>(i * <span class="hljs-number">10</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 使用对象数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arraySize; ++i) &#123;<br>        objArray[i].<span class="hljs-built_in">display</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 手动调用析构函数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arraySize; ++i) &#123;<br>        objArray[i].~<span class="hljs-built_in">MyClass</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](memory);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><strong>手动管理内存</strong>：使用定位 <code>new</code> 时，内存的分配和释放需要手动管理。需要确保在对象的生命周期结束时正确调用析构函数，并释放内存。</li><li><strong>异常安全性</strong>：如果构造函数抛出异常，需要确保已构造的对象正确析构，并释放内存。</li><li><strong>对齐要求</strong>：确保分配的内存满足对象的对齐要求。可以使用 <code>std::align</code> 函数来调整内存对齐。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>**定位 <code>new</code>**：用于在指定的内存地址上构造对象，允许在预先分配的内存中构造对象。</li><li><strong>语法</strong>：<code>new (address) Type(arguments);</code></li><li><strong>手动管理内存</strong>：需要手动管理内存的分配和释放，以及对象的构造和析构。</li><li><strong>应用场景</strong>：适用于需要精确控制内存布局或在预先分配的内存中构造对象的场景。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>placement new</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP 状态码</title>
    <link href="/2024/05/05/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <url>/2024/05/05/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><h2 id="消息响应"><a href="#消息响应" class="headerlink" title="消息响应"></a>消息响应</h2><table><thead><tr><th align="left">状态码</th><th align="left">原因短语</th><th align="left">代表含义</th><th align="left">HTTP 版本</th></tr></thead><tbody><tr><td align="left">100</td><td align="left">Continue(继续)</td><td align="left">客户端应当继续发送请求.这个临时响应是用来通知客户端它的部分请求已经被服务器接收,且仍未被拒绝.客户端应当继续发送请求的剩余部分,或者如果请求已经完成,忽略这个响应.服务器必须在请求完成后向客户端发送一个最终响应.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">101</td><td align="left">Switching Protocol(切换协议)</td><td align="left">服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到 在Upgrade消息头中定义的那些协议。: 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特 性的资源。</td><td align="left">HTTP&#x2F;1.1 可用</td></tr></tbody></table><h2 id="成功响应"><a href="#成功响应" class="headerlink" title="成功响应"></a>成功响应</h2><table><thead><tr><th align="left">状态码</th><th align="left">原因短语</th><th align="left">代表含义</th><th align="left">HTTP 版本</th></tr></thead><tbody><tr><td align="left">200</td><td align="left">OK(成功)</td><td align="left">请求成功.成功的意义根据请求所使用的方法不同而不同.- GET: 资源已被提取,并作为响应体传回客户端.- HEAD: 实体头已作为响应头传回客户端- POST: 经过服务器处理客户端传来的数据,适合的资源作为响应体传回客户端.- TRACE: 服务器收到请求消息作为响应体传回客户端.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">201</td><td align="left">Created(已创建)</td><td align="left">请求成功，而且有一个新的资源已经依据请求的需要而建立，通常这是 PUT 方法得到的响应码.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">202</td><td align="left">Accepted(已创建)</td><td align="left">服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。:返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">203</td><td align="left">Non-Authoritative Information(未授权信息)</td><td align="left">服务器已成功处理了请求,但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝,如果不是上述情况,使用200状态码才是最合适的.</td><td align="left">HTTP&#x2F;0.9 and 1.1</td></tr><tr><td align="left">204</td><td align="left">No Content(无内容)</td><td align="left">该响应没有响应内容,只有响应头,响应头也可能是有用的.用户代理可以根据新的响应头来更新对应资源的缓存信息.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">205</td><td align="left">Reset Content(重置内容)</td><td align="left">告诉用户代理去重置发送该请求的窗口的文档视图.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">206</td><td align="left">Partial Content(部分内容)</td><td align="left">当客户端通过使用range头字段进行文件分段下载时使用该状态码</td><td align="left">HTTP&#x2F;1.1 可用</td></tr></tbody></table><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><table><thead><tr><th align="left">状态码</th><th align="left">原因短语</th><th align="left">代表含义</th><th align="left">HTTP 版本</th></tr></thead><tbody><tr><td align="left">300</td><td align="left">Multiple Choice(多种选择)</td><td align="left">该请求有多种可能的响应,用户代理或者用户必须选择它们其中的一个.服务器没有任何标准可以遵循去代替用户来进行选择.</td><td align="left">HTTP&#x2F;1.0 and later</td></tr><tr><td align="left">301</td><td align="left">Moved Permanently(永久移动)</td><td align="left">该状态码表示所请求的URI资源路径已经改变,新的URL会在响应的 <code>Location</code> :头字段里找到.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">302</td><td align="left">Found(临时移动)</td><td align="left">该状态码表示所请求的URI资源路径临时改变,并且还可能继续改变.因此客户端在以后访问时还得继续使用该URI.新的URL会在响应的 <code>Location:</code> 头字段里找到.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">303</td><td align="left">See Other(查看其他位置)</td><td align="left">服务器发送该响应用来引导客户端使用GET方法访问另外一个URI.</td><td align="left">HTTP&#x2F;0.9 and 1.1</td></tr><tr><td align="left">304</td><td align="left">Not Modified(未修改)</td><td align="left">告诉客户端,所请求的内容距离上次访问并没有变化. 客户端可以直接从浏览器缓存里获取该资源.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">305</td><td align="left">Use Proxy(使用代理)</td><td align="left">所请求的资源必须统过代理才能访问到.由于安全原因,该状态码并未受到广泛支持.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">306</td><td align="left">unused(未使用)</td><td align="left">这个状态码已经不再被使用,当初它被用在HTTP 1.1规范的旧版本中.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">307</td><td align="left">Temporary Redirect(临时重定向)</td><td align="left">服务器发送该响应用来引导客户端使用相同的方法访问另外一个URI来获取想要获取的资源.新的URL会在响应的 <code>Location:</code> 头字段里找到.与302状态码有相同的语义,且前后两次访问必须使用相同的方法(GET POST).</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">308</td><td align="left">Permanent Redirect(永久重定向)</td><td align="left">所请求的资源将永久的位于另外一个URI上.新的URL会在响应的 <code>Location:</code> 头字段里找到.与301状态码有相同的语义,且前后两次访问必须使用相同的方法(GET POST).</td><td align="left">HTTPbis(试验草案)</td></tr></tbody></table><h2 id="客户端错误"><a href="#客户端错误" class="headerlink" title="客户端错误"></a>客户端错误</h2><table><thead><tr><th align="left">状态码</th><th align="left">原因短语</th><th align="left">代表含义</th><th align="left">HTTP 版本</th></tr></thead><tbody><tr><td align="left">400</td><td align="left">Bad Request(错误请求)</td><td align="left">因发送的请求语法错误,服务器无法正常读取.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">401</td><td align="left">Unauthorized(未授权)</td><td align="left">需要身份验证后才能获取所请求的内容,类似于403错误.不同点是.401错误后,只要正确输入帐号密码,验证即可通过.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">402</td><td align="left">Payment Required(需要付款)</td><td align="left">该状态码被保留以供将来使用.创建此代码最初的目的是为数字支付系统而用,然而,到现在也没投入使用.</td><td align="left">HTTP&#x2F;0.9 and 1.1</td></tr><tr><td align="left">403</td><td align="left">Forbidden(禁止访问)</td><td align="left">客户端没有权利访问所请求内容,服务器拒绝本次请求.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">404</td><td align="left">Not Found(未找到)</td><td align="left">服务器找不到所请求的资源.由于经常发生此种情况,所以该状态码在上网时是非常常见的.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">405</td><td align="left">Method Not Allowed(不允许使用该方法)</td><td align="left">该请求使用的方法被服务器端禁止使用,RFC2616中规定, <code>GET</code> 和 <code>HEAD</code> 方法不能被禁止.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">406</td><td align="left">Not Acceptable(无法接受)</td><td align="left">在进行服务器驱动内容协商后,没有发现合适的内容传回给客户端.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">407</td><td align="left">Proxy Authentication Required(要求代理身份验证)</td><td align="left">类似于状态码 401,不过需要通过代理才能进行验证.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">408</td><td align="left">Request Timeout(请求超时)</td><td align="left">客户端没有在服务器预备等待的时间内完成一个请求的发送.这意味着服务器将会切断和客户端的连接. 在其他浏览器中,这种响应更常见一些, 例如Chrome 和 IE9, 目的是为了使用HTTP 预连机制加快浏览速度. 同时注意,一些服务器不发送此种响应就直接切断连接.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">409</td><td align="left">Conflict(冲突)</td><td align="left">该请求与服务器的当前状态所冲突.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">410</td><td align="left">Gone(已失效)</td><td align="left">所请求的资源已经被删除.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">411</td><td align="left">Length Required(需要内容长度头)</td><td align="left">因服务器在本次请求中需要 <code>Content-Length</code> 头字段,而客户端没有发送.所以,服务器拒绝了该请求.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">412</td><td align="left">Precondition Failed(预处理失败)</td><td align="left">服务器没能满足客户端在获取资源时在请求头字段中设置的先决条件.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">413</td><td align="left">Request Entity Too Large(请求实体过长)</td><td align="left">请求实体大小超过服务器的设置的最大限制,服务器可能会关闭HTTP链接并返回 <code>Retry-After</code> 头字段.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">414</td><td align="left">Request-URI Too Long(请求网址过长)</td><td align="left">客户端请求所包含的URI地址太长,以至于服务器无法处理.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">415</td><td align="left">Unsupported Media Type(媒体类型不支持)</td><td align="left">服务器不支持客户端所请求的媒体类型,因此拒绝该请求.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">416</td><td align="left">Requested Range Not Satisfiable(请求范围不合要求)</td><td align="left">请求中包含的 <code>Range</code> 头字段无法被满足,通常是因为 <code>Range</code> 中的数字范围超出所请求资源的大小.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">417</td><td align="left">Expectation Failed(预期结果失败)</td><td align="left">在请求头 <code> Expect</code> 中指定的预期内容无法被服务器满足.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr></tbody></table><h2 id="服务器端错误"><a href="#服务器端错误" class="headerlink" title="服务器端错误"></a>服务器端错误</h2><table><thead><tr><th align="left">状态码</th><th align="left">原因短语</th><th align="left">代表含义</th><th align="left">HTTP 版本</th></tr></thead><tbody><tr><td align="left">500</td><td align="left">Internal Server Error(内部服务器错误)</td><td align="left">服务器遇到未知的无法解决的问题.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">501</td><td align="left">Not Implemented(未实现)</td><td align="left">服务器不支持该请求中使用的方法,比如 <code>POST</code> 和 <code>PUT.只有</code> <code>GET</code> 和 <code>HEAD</code> 是RFC2616规范中规定服务器必须实现的方法.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">502</td><td align="left">Bad Gateway(网关错误)</td><td align="left">服务器作为网关且从上游服务器获取到了一个无效的HTTP响应.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">503</td><td align="left">Service Unavailable(服务不可用)</td><td align="left">由于临时的服务器维护或者过载,服务器当前无法处理请求.这个状况是临时的,并且将在一段时间以后恢复.如果能够预计延迟时间,那么响应中可以包含一个 <code>Retry-After:</code> 头用以标明这个延迟时间.如果没有给出这个 <code>Retry-After:</code> 信息，那么客户端应当以处理500响应的方式处理它.同时,这种情况下,一个友好的用于解释服务器出现问题的页面应当被返回,并且,缓存相关的HTTP头信息也应该包含,因为通常这种错误提示网页不应当被客户端缓存.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">504</td><td align="left">Gateway Timeout(网关超时)</td><td align="left">服务器作为网关且不能从上游服务器及时的得到响应返回给客户端.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">505</td><td align="left">HTTP Version Not Supported(HTTP版本不受支持)</td><td align="left">服务器不支持客户端发送的HTTP请求中所使用的HTTP协议版本.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>CMake 命令 execute_process 详解</title>
    <link href="/2024/04/15/CMake%20%E5%91%BD%E4%BB%A4execute_jprocess/"/>
    <url>/2024/04/15/CMake%20%E5%91%BD%E4%BB%A4execute_jprocess/</url>
    
    <content type="html"><![CDATA[<h1 id="CMake-命令-execute-process-详解"><a href="#CMake-命令-execute-process-详解" class="headerlink" title="CMake 命令 execute_process 详解"></a>CMake 命令 execute_process 详解</h1><p><code>execute_process</code> 是 CMake 中的一个命令，用于在配置阶段执行外部进程。它可以运行外部程序或脚本，并捕获其输出。以下是 <code>execute_process</code> 命令的详细说明：</p><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">execute_process</span>(<span class="hljs-keyword">COMMAND</span> command1 [args1...]<br>                [<span class="hljs-keyword">COMMAND</span> command2 [args2...] ...]<br>                [WORKING_DIRECTORY dir]<br>                [TIMEOUT time]<br>                [RESULT_VARIABLE var]<br>                [OUTPUT_VARIABLE out_var]<br>                [ERROR_VARIABLE err_var]<br>                [INPUT_FILE <span class="hljs-keyword">file</span>]<br>                [OUTPUT_FILE <span class="hljs-keyword">file</span>]<br>                [ERROR_FILE <span class="hljs-keyword">file</span>]<br>                [OUTPUT_QUIET]<br>                [ERROR_QUIET]<br>                [OUTPUT_STRIP_TRAILING_WHITESPACE]<br>                [ERROR_STRIP_TRAILING_WHITESPACE]<br>                [ENCODING encoding])<br></code></pre></td></tr></table></figure><h2 id="参数详解"><a href="#参数详解" class="headerlink" title="参数详解"></a>参数详解</h2><ul><li><code>COMMAND</code>：指定要执行的命令及其参数。可以指定多个命令，按顺序执行。</li><li><code>WORKING_DIRECTORY</code>：指定命令执行时的工作目录。</li><li><code>TIMEOUT</code>：指定命令执行的超时时间（以秒为单位）。</li><li><code>RESULT_VARIABLE</code>：指定一个变量，用于存储命令的返回码。</li><li><code>OUTPUT_VARIABLE</code>：指定一个变量，用于存储命令的标准输出。</li><li><code>ERROR_VARIABLE</code>：指定一个变量，用于存储命令的标准错误输出。</li><li><code>INPUT_FILE</code>：指定一个文件，其内容将作为命令的标准输入。</li><li><code>OUTPUT_FILE</code>：指定一个文件，用于存储命令的标准输出。</li><li><code>ERROR_FILE</code>：指定一个文件，用于存储命令的标准错误输出。</li><li><code>OUTPUT_QUIET</code>：不显示命令的标准输出。</li><li><code>ERROR_QUIET</code>：不显示命令的标准错误输出。</li><li><code>OUTPUT_STRIP_TRAILING_WHITESPACE</code>：去除标准输出末尾的空白字符。</li><li><code>ERROR_STRIP_TRAILING_WHITESPACE</code>：去除标准错误输出末尾的空白字符。</li><li><code>ENCODING</code>：指定输出的编码格式。</li></ul><h2 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h2><p>以下是一个简单的示例，展示如何使用 <code>execute_process</code> 命令：</p><figure class="highlight cmake"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs cmake"><span class="hljs-keyword">cmake_minimum_required</span>(VERSION <span class="hljs-number">3.0</span>)<br><br><span class="hljs-keyword">project</span>(ExecuteProcessExample)<br><br><span class="hljs-comment"># 执行一个简单的命令，并捕获其输出</span><br><span class="hljs-keyword">execute_process</span>(<br>    <span class="hljs-keyword">COMMAND</span> echo <span class="hljs-string">&quot;Hello, World!&quot;</span><br>    OUTPUT_VARIABLE output<br>    ERROR_VARIABLE error<br>    RESULT_VARIABLE result<br>)<br><br><span class="hljs-comment"># 打印输出和结果</span><br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;Output: $&#123;output&#125;&quot;</span>)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;Error: $&#123;error&#125;&quot;</span>)<br><span class="hljs-keyword">message</span>(<span class="hljs-string">&quot;Result: $&#123;result&#125;&quot;</span>)<br></code></pre></td></tr></table></figure><p>在这个示例中，<code>execute_process</code> 命令执行了 <code>echo &quot;Hello, World!&quot;</code>，并将其标准输出、标准错误和返回码分别存储在 <code>output</code>、<code>error</code> 和 <code>result</code> 变量中。随后，使用 <code>message</code> 命令打印这些变量的值。</p>]]></content>
    
    
    <categories>
      
      <category>CMake</category>
      
    </categories>
    
    
    <tags>
      
      <tag>CMake</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 关闭笔记本自带键盘</title>
    <link href="/2024/04/15/Windows%E5%85%B3%E9%97%AD%E7%AC%94%E8%AE%B0%E6%9C%AC%E9%94%AE%E7%9B%98/"/>
    <url>/2024/04/15/Windows%E5%85%B3%E9%97%AD%E7%AC%94%E8%AE%B0%E6%9C%AC%E9%94%AE%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Windows-关闭笔记本自带键盘"><a href="#Windows-关闭笔记本自带键盘" class="headerlink" title="Windows 关闭笔记本自带键盘"></a>Windows 关闭笔记本自带键盘</h1><h2 id="关闭笔记本自带的键盘"><a href="#关闭笔记本自带的键盘" class="headerlink" title="关闭笔记本自带的键盘"></a>关闭笔记本自带的键盘</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">sc config i8042prt <span class="hljs-built_in">start</span> = disabled<br></code></pre></td></tr></table></figure><h2 id="打开笔记本自带的键盘"><a href="#打开笔记本自带的键盘" class="headerlink" title="打开笔记本自带的键盘"></a>打开笔记本自带的键盘</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">sc config i8042prt <span class="hljs-built_in">start</span>= auto<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Window 命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Window 命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hook malloc和free 段错误调试</title>
    <link href="/2023/10/12/Hook-malloc%E5%92%8Cfree-%E6%AE%B5%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/"/>
    <url>/2023/10/12/Hook-malloc%E5%92%8Cfree-%E6%AE%B5%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Hook-malloc-和-free-段错误调试"><a href="#Hook-malloc-和-free-段错误调试" class="headerlink" title="Hook malloc 和 free 段错误调试"></a>Hook malloc 和 free 段错误调试</h1><h2 id="1、自定义的-malloc-和-free"><a href="#1、自定义的-malloc-和-free" class="headerlink" title="1、自定义的 malloc 和 free"></a>1、自定义的 <code>malloc</code> 和 <code>free</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// my_malloc.c</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">void</span>* (*real_malloc)(<span class="hljs-type">size_t</span>) = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (!real_malloc) &#123;<br>        real_malloc = dlsym(RTLD_NEXT, <span class="hljs-string">&quot;malloc&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!real_malloc) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Error in `dlsym`: %s\n&quot;</span>, dlerror());<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">void</span>* ptr = real_malloc(size);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc(%zu) = %p\n&quot;</span>, size, ptr);<br>    <span class="hljs-keyword">return</span> ptr;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*real_free)</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span> = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (!real_free) &#123;<br>        real_free = dlsym(RTLD_NEXT, <span class="hljs-string">&quot;free&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!real_free) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Error in `dlsym`: %s\n&quot;</span>, dlerror());<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;free(%p)\n&quot;</span>, ptr);<br>    real_free(ptr);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -shared -fPIC -o libmymalloc.so my_malloc.c -ldl<br></code></pre></td></tr></table></figure><h2 id="2、测试程序"><a href="#2、测试程序" class="headerlink" title="2、测试程序"></a>2、测试程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.c</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;enter main...\n&quot;</span>);<br><br>    <span class="hljs-type">int</span> *p = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">// 分配足够的内存</span><br>    <span class="hljs-keyword">if</span> (!p) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;allocation error...\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;returning to main...\n&quot;</span>);<br><br>    <span class="hljs-built_in">free</span>(p);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>) == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hook strcmp\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;not match\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译命令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">gcc main.c libmymalloc.so -o main -g<br></code></pre></td></tr></table></figure><h2 id="3、运行结果（段错误）"><a href="#3、运行结果（段错误）" class="headerlink" title="3、运行结果（段错误）"></a>3、运行结果（段错误）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">linhanmic@MOSS:~/study$ ./main<br>Segmentation fault<br></code></pre></td></tr></table></figure><h2 id="4、gdb-调试"><a href="#4、gdb-调试" class="headerlink" title="4、gdb 调试"></a>4、gdb 调试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Temporary breakpoint 1, main () at main.c:7<br>7           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;enter main...\n&quot;</span>);<br>(gdb) n<br><br>Program received signal SIGSEGV, Segmentation fault.<br>0x00007ffff7e01097 <span class="hljs-keyword">in</span> __printf_buffer (buf=buf@entry=0x7fffff7ff370,<br>    format=format@entry=0x7ffff7fba01d <span class="hljs-string">&quot;malloc(%zu) = %p\n&quot;</span>, ap=ap@entry=0x7fffff7ff470, mode_flags=mode_flags@entry=0)<br>    at ./stdio-common/vfprintf-internal.c:600<br></code></pre></td></tr></table></figure><h2 id="5、错误分析"><a href="#5、错误分析" class="headerlink" title="5、错误分析"></a>5、错误分析</h2><p>根据调试信息发现，段错误发生在 <code>printf</code> 函数中，由于 <code>printf</code> 函数内部调用了 <code>malloc</code> ，而 hook 后的 <code>malloc</code> 内部又调用了 <code>printf</code> 函数，导致函数 <code>递归调用</code> 造成 <code>栈溢出</code>，出现 <code>Segmentation fault</code> 。</p><h2 id="6、解决方案"><a href="#6、解决方案" class="headerlink" title="6、解决方案"></a>6、解决方案</h2><p>避免在<code>malloc</code>和<code>free</code>中调用<code>printf</code>：可以使用<code>write</code>函数代替<code>printf</code>，因为<code>write</code>是一个系统调用，不会调用<code>malloc</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">void</span>* (*real_malloc)(<span class="hljs-type">size_t</span>) = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (!real_malloc) &#123;<br>        real_malloc = dlsym(RTLD_NEXT, <span class="hljs-string">&quot;malloc&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!real_malloc) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">char</span> *error = <span class="hljs-string">&quot;Error in `dlsym` for `malloc`\n&quot;</span>;<br>            write(STDERR_FILENO, error, <span class="hljs-built_in">strlen</span>(error));<br>            _exit(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">void</span>* ptr = real_malloc(size);<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">256</span>];<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">snprintf</span>(buffer, <span class="hljs-keyword">sizeof</span>(buffer), <span class="hljs-string">&quot;malloc(%zu) = %p\n&quot;</span>, size, ptr);<br>    write(STDOUT_FILENO, buffer, len);<br>    <span class="hljs-keyword">return</span> ptr;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*real_free)</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span> = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (!real_free) &#123;<br>        real_free = dlsym(RTLD_NEXT, <span class="hljs-string">&quot;free&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!real_free) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">char</span> *error = <span class="hljs-string">&quot;Error in `dlsym` for `free`\n&quot;</span>;<br>            write(STDERR_FILENO, error, <span class="hljs-built_in">strlen</span>(error));<br>            _exit(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">256</span>];<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">snprintf</span>(buffer, <span class="hljs-keyword">sizeof</span>(buffer), <span class="hljs-string">&quot;free(%p)\n&quot;</span>, ptr);<br>    write(STDOUT_FILENO, buffer, len);<br>    real_free(ptr);<br>&#125;<br></code></pre></td></tr></table></figure><p>修改后的运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">linhanmic@MOSS:~/study$ ./main<br>malloc(1024) = 0x558cae5fa2a0<br>enter main...<br>malloc(40) = 0x558cae5fa6b0<br>returning to main...<br>free(0x558cae5fa6b0)<br>not match<br></code></pre></td></tr></table></figure><h2 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h2><p>1、在 hook 时调用其他函数，由于不知道函数内部实现容易出现递归调用导致栈溢出</p><p>2、善用 <code>gdb</code> 调试程序能够快速地定位错误，达到事半功倍的效果</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Debug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Hook</tag>
      
      <tag>Segmentation fault</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 类之构造函数</title>
    <link href="/2023/10/06/C++%20%E7%B1%BB%E4%B9%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <url>/2023/10/06/C++%20%E7%B1%BB%E4%B9%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="C-类之构造函数"><a href="#C-类之构造函数" class="headerlink" title="C++ 类之构造函数"></a>C++ 类之构造函数</h1><p>在C++中，构造函数是用于初始化对象的特殊成员函数。构造函数有多种类型，包括默认构造函数、参数化构造函数、拷贝构造函数和移动构造函数。以下是对这些构造函数的详细总结和解释。</p><h3 id="1-默认构造函数"><a href="#1-默认构造函数" class="headerlink" title="1. 默认构造函数"></a>1. 默认构造函数</h3><p>默认构造函数是在没有参数的情况下创建对象时调用的构造函数。如果没有显式定义，编译器会生成一个默认构造函数。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123;<br>        <span class="hljs-comment">// 默认构造函数</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-参数化构造函数"><a href="#2-参数化构造函数" class="headerlink" title="2. 参数化构造函数"></a>2. 参数化构造函数</h3><p>参数化构造函数允许在创建对象时传递参数，以初始化对象的成员变量。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">double</span> y) : <span class="hljs-built_in">a</span>(x), <span class="hljs-built_in">b</span>(y) &#123;<br>        <span class="hljs-comment">// 参数化构造函数</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">double</span> b;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-拷贝构造函数"><a href="#3-拷贝构造函数" class="headerlink" title="3. 拷贝构造函数"></a>3. 拷贝构造函数</h3><p>拷贝构造函数用于通过另一个同类型的对象来初始化新对象。它通常用于复制对象的资源。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp; other) : <span class="hljs-built_in">a</span>(other.a), <span class="hljs-built_in">b</span>(other.b) &#123;<br>        <span class="hljs-comment">// 拷贝构造函数</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">double</span> b;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-移动构造函数"><a href="#4-移动构造函数" class="headerlink" title="4. 移动构造函数"></a>4. 移动构造函数</h3><p>移动构造函数用于通过移动另一个同类型的对象来初始化新对象。它通常用于转移对象的资源，而不是复制它们。</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">a</span>(other.a), <span class="hljs-built_in">b</span>(other.b) &#123;<br>        other.a = <span class="hljs-number">0</span>;<br>        other.b = <span class="hljs-number">0.0</span>;<br>        <span class="hljs-comment">// 移动构造函数</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">double</span> b;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-析构函数"><a href="#5-析构函数" class="headerlink" title="5. 析构函数"></a>5. 析构函数</h3><p>析构函数用于在对象生命周期结束时清理资源。它的名称与类名相同，但前面有一个波浪号（<code>~</code>）。</p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        <span class="hljs-comment">// 析构函数</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-完整示例"><a href="#6-完整示例" class="headerlink" title="6. 完整示例"></a>6. 完整示例</h3><p>以下是一个包含所有类型构造函数和析构函数的完整示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span> <span class="hljs-comment">// for std::move</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">MyClass</span>() : <span class="hljs-built_in">a</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">b</span>(<span class="hljs-number">0.0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Default constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 参数化构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">double</span> y) : <span class="hljs-built_in">a</span>(x), <span class="hljs-built_in">b</span>(y) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Parameterized constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp; other) : <span class="hljs-built_in">a</span>(other.a), <span class="hljs-built_in">b</span>(other.b) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Copy constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">a</span>(other.a), <span class="hljs-built_in">b</span>(other.b) &#123;<br>        other.a = <span class="hljs-number">0</span>;<br>        other.b = <span class="hljs-number">0.0</span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Move constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印数据</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">double</span> b;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj1; <span class="hljs-comment">// 调用默认构造函数</span><br>    <span class="hljs-function">MyClass <span class="hljs-title">obj2</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20.5</span>)</span></span>; <span class="hljs-comment">// 调用参数化构造函数</span><br>    MyClass obj3 = obj2; <span class="hljs-comment">// 调用拷贝构造函数</span><br>    MyClass obj4 = std::<span class="hljs-built_in">move</span>(obj2); <span class="hljs-comment">// 调用移动构造函数</span><br><br>    obj<span class="hljs-number">1.</span><span class="hljs-built_in">print</span>();<br>    obj<span class="hljs-number">2.</span><span class="hljs-built_in">print</span>(); <span class="hljs-comment">// 被移动后，obj2 的值被重置</span><br>    obj<span class="hljs-number">3.</span><span class="hljs-built_in">print</span>();<br>    obj<span class="hljs-number">4.</span><span class="hljs-built_in">print</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">Default</span> <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Parameterized</span> <span class="hljs-title">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Copy</span> <span class="hljs-title">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Move</span> <span class="hljs-title">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">a</span>:</span> <span class="hljs-number">0</span>, b: <span class="hljs-number">0</span><br>a: <span class="hljs-number">0</span>, b: <span class="hljs-number">0</span><br>a: <span class="hljs-number">10</span>, b: <span class="hljs-number">20.5</span><br>a: <span class="hljs-number">10</span>, b: <span class="hljs-number">20.5</span><br><span class="hljs-function"><span class="hljs-keyword">Destructor</span></span><br><span class="hljs-function"><span class="hljs-title">Destructor</span></span><br><span class="hljs-function"><span class="hljs-title">Destructor</span></span><br><span class="hljs-function"><span class="hljs-title">Destructor</span></span><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>默认构造函数</strong>：在没有参数的情况下创建对象时调用。</li><li><strong>参数化构造函数</strong>：允许在创建对象时传递参数，以初始化对象的成员变量。</li><li><strong>拷贝构造函数</strong>：通过另一个同类型的对象来初始化新对象，通常用于复制对象的资源。</li><li><strong>移动构造函数</strong>：通过移动另一个同类型的对象来初始化新对象，通常用于转移对象的资源。</li><li><strong>析构函数</strong>：在对象生命周期结束时清理资源。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>构造函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 类之拷贝控制</title>
    <link href="/2023/10/05/C++%20%E7%B1%BB%E4%B9%8B%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/"/>
    <url>/2023/10/05/C++%20%E7%B1%BB%E4%B9%8B%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="C-类之拷贝控制"><a href="#C-类之拷贝控制" class="headerlink" title="C++ 类之拷贝控制"></a>C++ 类之拷贝控制</h1><p>在C++中，拷贝控制（Copy Control）是指管理对象的复制、移动和销毁的机制。拷贝控制主要涉及以下五个成员函数：</p><ol><li>拷贝构造函数（Copy Constructor）</li><li>拷贝赋值运算符（Copy Assignment Operator）</li><li>移动构造函数（Move Constructor）</li><li>移动赋值运算符（Move Assignment Operator）</li><li>析构函数（Destructor）</li></ol><p>这些成员函数共同负责对象的生命周期管理，包括对象的创建、复制、移动和销毁。</p><h3 id="1-拷贝构造函数"><a href="#1-拷贝构造函数" class="headerlink" title="1. 拷贝构造函数"></a>1. 拷贝构造函数</h3><p>拷贝构造函数用于通过另一个同类型的对象来初始化新对象。它通常用于复制对象的资源。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp; other) : <span class="hljs-built_in">a</span>(other.a) &#123;<br>        <span class="hljs-comment">// 拷贝构造函数</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-拷贝赋值运算符"><a href="#2-拷贝赋值运算符" class="headerlink" title="2. 拷贝赋值运算符"></a>2. 拷贝赋值运算符</h3><p>拷贝赋值运算符用于将一个已有对象的资源复制到另一个已有对象中。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    MyClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            a = other.a;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-移动构造函数"><a href="#3-移动构造函数" class="headerlink" title="3. 移动构造函数"></a>3. 移动构造函数</h3><p>移动构造函数用于通过移动另一个同类型的对象来初始化新对象。它通常用于转移对象的资源，而不是复制它们。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">a</span>(other.a) &#123;<br>        other.a = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">// 移动构造函数</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* a;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-移动赋值运算符"><a href="#4-移动赋值运算符" class="headerlink" title="4. 移动赋值运算符"></a>4. 移动赋值运算符</h3><p>移动赋值运算符用于将一个已有对象的资源移动到另一个已有对象中。</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    MyClass&amp; <span class="hljs-keyword">operator</span>=(MyClass&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-keyword">delete</span> a;<br>            a = other.a;<br>            other.a = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* a;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-析构函数"><a href="#5-析构函数" class="headerlink" title="5. 析构函数"></a>5. 析构函数</h3><p>析构函数用于在对象生命周期结束时清理资源。它的名称与类名相同，但前面有一个波浪号（<code>~</code>）。</p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        <span class="hljs-comment">// 析构函数</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="拷贝控制的规则"><a href="#拷贝控制的规则" class="headerlink" title="拷贝控制的规则"></a>拷贝控制的规则</h3><p>C++11引入了”Rule of Three”和”Rule of Five”来帮助开发者管理拷贝控制函数。</p><h4 id="Rule-of-Three"><a href="#Rule-of-Three" class="headerlink" title="Rule of Three"></a>Rule of Three</h4><p>如果一个类需要自定义拷贝构造函数、拷贝赋值运算符或析构函数中的任何一个，那么它很可能需要自定义所有这三个函数。</p><h4 id="Rule-of-Five"><a href="#Rule-of-Five" class="headerlink" title="Rule of Five"></a>Rule of Five</h4><p>C++11引入了移动语义，因此如果一个类需要自定义拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符或析构函数中的任何一个，那么它很可能需要自定义所有这五个函数。</p><h3 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h3><p>以下是一个包含所有拷贝控制函数的完整示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span> <span class="hljs-comment">// for std::move</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">MyClass</span>() : <span class="hljs-built_in">a</span>(<span class="hljs-literal">nullptr</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Default constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 参数化构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">a</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(x)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Parameterized constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp; other) : <span class="hljs-built_in">a</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.a)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Copy constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">a</span>(other.a) &#123;<br>        other.a = <span class="hljs-literal">nullptr</span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Move constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝赋值运算符</span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-keyword">delete</span> a;<br>            a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.a);<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Copy assignment operator&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动赋值运算符</span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>=(MyClass&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-keyword">delete</span> a;<br>            a = other.a;<br>            other.a = <span class="hljs-literal">nullptr</span>;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Move assignment operator&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        <span class="hljs-keyword">delete</span> a;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印数据</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (a) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;a: &quot;</span> &lt;&lt; *a &lt;&lt; std::endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;a is null&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// 调用参数化构造函数</span><br>    MyClass obj2 = obj1; <span class="hljs-comment">// 调用拷贝构造函数</span><br>    MyClass obj3 = std::<span class="hljs-built_in">move</span>(obj1); <span class="hljs-comment">// 调用移动构造函数</span><br><br>    <span class="hljs-function">MyClass <span class="hljs-title">obj4</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>; <span class="hljs-comment">// 调用参数化构造函数</span><br>    obj4 = obj2; <span class="hljs-comment">// 调用拷贝赋值运算符</span><br>    obj4 = std::<span class="hljs-built_in">move</span>(obj3); <span class="hljs-comment">// 调用移动赋值运算符</span><br><br>    obj<span class="hljs-number">1.</span><span class="hljs-built_in">print</span>(); <span class="hljs-comment">// 被移动后，obj1 的值被重置</span><br>    obj<span class="hljs-number">2.</span><span class="hljs-built_in">print</span>();<br>    obj<span class="hljs-number">3.</span><span class="hljs-built_in">print</span>(); <span class="hljs-comment">// 被移动后，obj3 的值被重置</span><br>    obj<span class="hljs-number">4.</span><span class="hljs-built_in">print</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs delphi">Parameterized <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Copy</span> <span class="hljs-title">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Move</span> <span class="hljs-title">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Parameterized</span> <span class="hljs-title">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Copy</span> <span class="hljs-title">assignment</span> <span class="hljs-title">operator</span></span><br><span class="hljs-function"><span class="hljs-title">Move</span> <span class="hljs-title">assignment</span> <span class="hljs-title">operator</span></span><br><span class="hljs-function"><span class="hljs-title">a</span> <span class="hljs-title">is</span> <span class="hljs-title">null</span></span><br><span class="hljs-function"><span class="hljs-title">a</span>:</span> <span class="hljs-number">10</span><br>a <span class="hljs-keyword">is</span> null<br>a: <span class="hljs-number">10</span><br><span class="hljs-function"><span class="hljs-keyword">Destructor</span></span><br><span class="hljs-function"><span class="hljs-title">Destructor</span></span><br><span class="hljs-function"><span class="hljs-title">Destructor</span></span><br><span class="hljs-function"><span class="hljs-title">Destructor</span></span><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>拷贝构造函数</strong>：用于通过另一个同类型的对象来初始化新对象。</li><li><strong>拷贝赋值运算符</strong>：用于将一个已有对象的资源复制到另一个已有对象中。</li><li><strong>移动构造函数</strong>：用于通过移动另一个同类型的对象来初始化新对象。</li><li><strong>移动赋值运算符</strong>：用于将一个已有对象的资源移动到另一个已有对象中。</li><li><strong>析构函数</strong>：用于在对象生命周期结束时清理资源。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>拷贝控制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim -多行注释</title>
    <link href="/2023/09/05/Vim-%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A/"/>
    <url>/2023/09/05/Vim-%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="Vim-多行注释"><a href="#Vim-多行注释" class="headerlink" title="Vim -多行注释"></a>Vim -多行注释</h1><p>操作步骤如下：</p><ol><li>移动光标到要注释的起始行的行首</li><li>Ctrl + q 进入可视块模式</li><li>移动光标选中要注释的代码行</li><li>Shift + i 进入插入模式，键入当前语言的注释符</li><li>按Esc键后，之前选中的代码行会全部加上了注释符</li></ol><p>其实，这里并不局限于注释代码，这里的操作叫<code>列插入</code>更合适，也就是可以在多行代码的同一列插入同样的任意字符。</p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 类之访问控制</title>
    <link href="/2023/07/05/C++%20%E7%B1%BB%E4%B9%8B%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"/>
    <url>/2023/07/05/C++%20%E7%B1%BB%E4%B9%8B%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="C-类之访问控制"><a href="#C-类之访问控制" class="headerlink" title="C++ 类之访问控制"></a>C++ 类之访问控制</h1><p>在C++中，访问控制（Access Control）是指控制类成员（变量和函数）的访问权限。访问控制通过访问说明符（Access Specifiers）来实现，主要有以下三种：</p><ol><li><code>public</code>：公有访问权限</li><li><code>protected</code>：受保护访问权限</li><li><code>private</code>：私有访问权限</li></ol><p>此外，C++还提供了友元函数和友元类机制，以允许特定的非成员函数或类访问类的私有和受保护成员。</p><h3 id="1-public-访问权限"><a href="#1-public-访问权限" class="headerlink" title="1. public 访问权限"></a>1. <code>public</code> 访问权限</h3><ul><li><strong>描述</strong>：公有成员可以在类的外部被访问。</li><li><strong>应用场景</strong>：用于需要在类的外部访问的成员，如接口函数。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> publicVar;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">publicMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 公有方法</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    obj.publicVar = <span class="hljs-number">10</span>; <span class="hljs-comment">// 访问公有成员变量</span><br>    obj.<span class="hljs-built_in">publicMethod</span>(); <span class="hljs-comment">// 调用公有成员函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-protected-访问权限"><a href="#2-protected-访问权限" class="headerlink" title="2. protected 访问权限"></a>2. <code>protected</code> 访问权限</h3><ul><li><strong>描述</strong>：受保护成员可以在类的内部和派生类中被访问，但不能在类的外部被访问。</li><li><strong>应用场景</strong>：用于需要在派生类中访问但不希望在类的外部访问的成员。</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> protectedVar;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">protectedMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 受保护方法</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">accessProtected</span><span class="hljs-params">()</span> </span>&#123;<br>        protectedVar = <span class="hljs-number">10</span>; <span class="hljs-comment">// 访问基类的受保护成员变量</span><br>        <span class="hljs-built_in">protectedMethod</span>(); <span class="hljs-comment">// 调用基类的受保护成员函数</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived obj;<br>    obj.<span class="hljs-built_in">accessProtected</span>();<br>    <span class="hljs-comment">// obj.protectedVar = 10; // 错误：不能在类的外部访问受保护成员</span><br>    <span class="hljs-comment">// obj.protectedMethod(); // 错误：不能在类的外部调用受保护成员函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-private-访问权限"><a href="#3-private-访问权限" class="headerlink" title="3. private 访问权限"></a>3. <code>private</code> 访问权限</h3><ul><li><strong>描述</strong>：私有成员仅可以在类的内部被访问，不能在类的外部或派生类中被访问。</li><li><strong>应用场景</strong>：用于仅在类的内部访问的成员，通常用于实现细节。</li></ul><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> privateVar;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">privateMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 私有方法</span><br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">accessPrivate</span><span class="hljs-params">()</span> </span>&#123;<br>        privateVar = <span class="hljs-number">10</span>; <span class="hljs-comment">// 访问私有成员变量</span><br>        <span class="hljs-built_in">privateMethod</span>(); <span class="hljs-comment">// 调用私有成员函数</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    obj.<span class="hljs-built_in">accessPrivate</span>();<br>    <span class="hljs-comment">// obj.privateVar = 10; // 错误：不能在类的外部访问私有成员</span><br>    <span class="hljs-comment">// obj.privateMethod(); // 错误：不能在类的外部调用私有成员函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-友元函数和友元类"><a href="#4-友元函数和友元类" class="headerlink" title="4. 友元函数和友元类"></a>4. 友元函数和友元类</h3><ul><li><strong>友元函数</strong>：非成员函数，但被授予访问类的私有和受保护成员的权限。常用于操作符重载和辅助函数。</li><li><strong>友元类</strong>：一个类，被授予访问另一个类的私有和受保护成员的权限。常用于紧密耦合的类之间的合作。</li></ul><h4 id="友元函数示例"><a href="#友元函数示例" class="headerlink" title="友元函数示例"></a>友元函数示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> privateVar;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">privateVar</span>(x) &#123;&#125;<br><br>    <span class="hljs-comment">// 声明友元函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">printPrivateVar</span><span class="hljs-params">(<span class="hljs-type">const</span> MyClass&amp; obj)</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// 定义友元函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPrivateVar</span><span class="hljs-params">(<span class="hljs-type">const</span> MyClass&amp; obj)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Private variable: &quot;</span> &lt;&lt; obj.privateVar &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-built_in">printPrivateVar</span>(obj); <span class="hljs-comment">// 调用友元函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="友元类示例"><a href="#友元类示例" class="headerlink" title="友元类示例"></a>友元类示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> privateVar;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">privateVar</span>(x) &#123;&#125;<br><br>    <span class="hljs-comment">// 声明友元类</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FriendClass</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FriendClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPrivateVar</span><span class="hljs-params">(<span class="hljs-type">const</span> MyClass&amp; obj)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Private variable: &quot;</span> &lt;&lt; obj.privateVar &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    FriendClass friendObj;<br>    friendObj.<span class="hljs-built_in">printPrivateVar</span>(obj); <span class="hljs-comment">// 调用友元类的方法</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-访问控制的继承关系"><a href="#5-访问控制的继承关系" class="headerlink" title="5. 访问控制的继承关系"></a>5. 访问控制的继承关系</h3><p>在继承关系中，基类的访问控制会影响派生类对基类成员的访问权限。继承方式有三种：<code>public</code> 继承、<code>protected</code> 继承和 <code>private</code> 继承。</p><h4 id="public-继承"><a href="#public-继承" class="headerlink" title="public 继承"></a><code>public</code> 继承</h4><ul><li>基类的 <code>public</code> 成员在派生类中仍然是 <code>public</code>。</li><li>基类的 <code>protected</code> 成员在派生类中仍然是 <code>protected</code>。</li></ul><h4 id="protected-继承"><a href="#protected-继承" class="headerlink" title="protected 继承"></a><code>protected</code> 继承</h4><ul><li>基类的 <code>public</code> 成员在派生类中变为 <code>protected</code>。</li><li>基类的 <code>protected</code> 成员在派生类中仍然是 <code>protected</code>。</li></ul><h4 id="private-继承"><a href="#private-继承" class="headerlink" title="private 继承"></a><code>private</code> 继承</h4><ul><li>基类的 <code>public</code> 和 <code>protected</code> 成员在派生类中都变为 <code>private</code>。</li></ul><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> publicVar;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> protectedVar;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> privateVar;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PublicDerived</span> : <span class="hljs-keyword">public</span> Base &#123;<br>    <span class="hljs-comment">// publicVar 是 public</span><br>    <span class="hljs-comment">// protectedVar 是 protected</span><br>    <span class="hljs-comment">// privateVar 不能访问</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProtectedDerived</span> : <span class="hljs-keyword">protected</span> Base &#123;<br>    <span class="hljs-comment">// publicVar 是 protected</span><br>    <span class="hljs-comment">// protectedVar 是 protected</span><br>    <span class="hljs-comment">// privateVar 不能访问</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrivateDerived</span> : <span class="hljs-keyword">private</span> Base &#123;<br>    <span class="hljs-comment">// publicVar 是 private</span><br>    <span class="hljs-comment">// protectedVar 是 private</span><br>    <span class="hljs-comment">// privateVar 不能访问</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>**<code>public</code>**：公有访问权限，允许类的成员在类的外部被访问。</li><li>**<code>protected</code>**：受保护访问权限，允许类的成员在类的内部和派生类中被访问。</li><li>**<code>private</code>**：私有访问权限，允许类的成员仅在类的内部被访问。</li><li><strong>友元函数和友元类</strong>：允许特定的非成员函数或类访问类的私有和受保护成员。</li><li><strong>继承关系中的访问控制</strong>：基类的访问控制会影响派生类对基类成员的访问权限，具体取决于继承方式（<code>public</code>、<code>protected</code>、<code>private</code>）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>访问控制</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
