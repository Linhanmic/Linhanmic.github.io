<?xml version="1.0" encoding="utf-8"?>
<search>
  
  
  
  <entry>
    <title>C++ 枚举类型</title>
    <link href="/2024/09/13/C++%20%E6%9E%9A%E4%B8%BE/"/>
    <url>/2024/09/13/C++%20%E6%9E%9A%E4%B8%BE/</url>
    
    <content type="html"><![CDATA[<h1 id="C-枚举类型"><a href="#C-枚举类型" class="headerlink" title="C++ 枚举类型"></a>C++ 枚举类型</h1><p>在C++中，枚举（enum）是一种用户定义的类型，用于表示一组命名的常量。C++11引入了强类型枚举（enum class），提供了更强的类型安全性和作用域控制。以下是对传统枚举（enum）和强类型枚举（enum class）的详细总结。</p><h3 id="1-传统枚举（enum）"><a href="#1-传统枚举（enum）" class="headerlink" title="1. 传统枚举（enum）"></a>1. 传统枚举（enum）</h3><p>传统枚举是C++中最早引入的一种枚举类型，定义在全局作用域或类作用域中。传统枚举的枚举值是整型常量，可以隐式转换为整数类型。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    Red,<br>    Green,<br>    Blue<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Color color = Red;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Color: &quot;</span> &lt;&lt; color &lt;&lt; std::endl; <span class="hljs-comment">// 输出：Color: 0</span><br><br>    <span class="hljs-comment">// 隐式转换为整数</span><br>    <span class="hljs-type">int</span> colorValue = color;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Color value: &quot;</span> &lt;&lt; colorValue &lt;&lt; std::endl; <span class="hljs-comment">// 输出：Color value: 0</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>隐式转换</strong>：枚举值可以隐式转换为整数类型。</li><li><strong>作用域</strong>：枚举值在定义的作用域内是全局的，可能会导致命名冲突。</li><li><strong>类型安全性</strong>：较低，枚举值可以隐式转换为整数，容易引发错误。</li></ul><h3 id="2-强类型枚举（enum-class）"><a href="#2-强类型枚举（enum-class）" class="headerlink" title="2. 强类型枚举（enum class）"></a>2. 强类型枚举（enum class）</h3><p>C++11引入了强类型枚举（enum class），提供了更强的类型安全性和作用域控制。强类型枚举的枚举值不能隐式转换为整数类型，必须显式转换。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span> &#123;<br>    Red,<br>    Green,<br>    Blue<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Color color = Color::Red;<br>    <span class="hljs-comment">// std::cout &lt;&lt; &quot;Color: &quot; &lt;&lt; color &lt;&lt; std::endl; // 错误：不能隐式转换为整数</span><br><br>    <span class="hljs-comment">// 显式转换为整数</span><br>    <span class="hljs-type">int</span> colorValue = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">int</span>&gt;(color);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Color value: &quot;</span> &lt;&lt; colorValue &lt;&lt; std::endl; <span class="hljs-comment">// 输出：Color value: 0</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="特点-1"><a href="#特点-1" class="headerlink" title="特点"></a>特点</h4><ul><li><strong>显式转换</strong>：枚举值不能隐式转换为整数类型，必须显式转换。</li><li><strong>作用域</strong>：枚举值在定义的作用域内是局部的，避免了命名冲突。</li><li><strong>类型安全性</strong>：更高，枚举值不能隐式转换为整数，减少了错误的可能性。</li></ul><h3 id="3-枚举的定义和使用"><a href="#3-枚举的定义和使用" class="headerlink" title="3. 枚举的定义和使用"></a>3. 枚举的定义和使用</h3><h4 id="传统枚举的定义和使用"><a href="#传统枚举的定义和使用" class="headerlink" title="传统枚举的定义和使用"></a>传统枚举的定义和使用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum</span> <span class="hljs-title class_">Color</span> &#123;<br>    Red,<br>    Green,<br>    Blue<br>&#125;;<br><br>Color color = Red;<br></code></pre></td></tr></table></figure><h4 id="强类型枚举的定义和使用"><a href="#强类型枚举的定义和使用" class="headerlink" title="强类型枚举的定义和使用"></a>强类型枚举的定义和使用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span> &#123;<br>    Red,<br>    Green,<br>    Blue<br>&#125;;<br><br>Color color = Color::Red;<br></code></pre></td></tr></table></figure><h3 id="4-枚举的底层类型"><a href="#4-枚举的底层类型" class="headerlink" title="4. 枚举的底层类型"></a>4. 枚举的底层类型</h3><p>在C++11及其后续版本中，可以指定枚举的底层类型。默认情况下，底层类型是 <code>int</code>。</p><h4 id="示例：指定底层类型"><a href="#示例：指定底层类型" class="headerlink" title="示例：指定底层类型"></a>示例：指定底层类型</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span> : <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> &#123;<br>    Red,<br>    Green,<br>    Blue<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Color color = Color::Red;<br>    <span class="hljs-type">unsigned</span> <span class="hljs-type">int</span> colorValue = <span class="hljs-built_in">static_cast</span>&lt;<span class="hljs-type">unsigned</span> <span class="hljs-type">int</span>&gt;(color);<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Color value: &quot;</span> &lt;&lt; colorValue &lt;&lt; std::endl; <span class="hljs-comment">// 输出：Color value: 0</span><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-枚举的比较"><a href="#5-枚举的比较" class="headerlink" title="5. 枚举的比较"></a>5. 枚举的比较</h3><p>枚举值可以进行比较操作，如相等性比较和关系比较。</p><h4 id="示例：枚举的比较"><a href="#示例：枚举的比较" class="headerlink" title="示例：枚举的比较"></a>示例：枚举的比较</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><br><span class="hljs-keyword">enum class</span> <span class="hljs-title class_">Color</span> &#123;<br>    Red,<br>    Green,<br>    Blue<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Color color1 = Color::Red;<br>    Color color2 = Color::Green;<br><br>    <span class="hljs-keyword">if</span> (color1 == Color::Red) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;color1 is Red&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">if</span> (color1 != color2) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;color1 is not equal to color2&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><p><strong>传统枚举（enum）</strong>：</p><ul><li><strong>隐式转换</strong>：枚举值可以隐式转换为整数类型。</li><li><strong>作用域</strong>：枚举值在定义的作用域内是全局的，可能会导致命名冲突。</li><li><strong>类型安全性</strong>：较低，枚举值可以隐式转换为整数，容易引发错误。</li></ul></li><li><p><strong>强类型枚举（enum class）</strong>：</p><ul><li><strong>显式转换</strong>：枚举值不能隐式转换为整数类型，必须显式转换。</li><li><strong>作用域</strong>：枚举值在定义的作用域内是局部的，避免了命名冲突。</li><li><strong>类型安全性</strong>：更高，枚举值不能隐式转换为整数，减少了错误的可能性。</li><li><strong>底层类型</strong>：可以指定枚举的底层类型。</li></ul></li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>枚举类型</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>设计模式之设计原则</title>
    <link href="/2024/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/"/>
    <url>/2024/09/06/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F%E4%B9%8B%E8%AE%BE%E8%AE%A1%E5%8E%9F%E5%88%99/</url>
    
    <content type="html"><![CDATA[<h1 id="C-设计模式之设计原则"><a href="#C-设计模式之设计原则" class="headerlink" title="C++ 设计模式之设计原则"></a>C++ 设计模式之设计原则</h1><p>设计模式中的设计原则是指导软件设计的基本准则，旨在提高代码的可维护性、可扩展性和灵活性。这些原则帮助开发者编写出更健壮、更易于理解和更易于修改的代码。以下是一些关键的设计原则及其总结：</p><h3 id="1-单一职责原则"><a href="#1-单一职责原则" class="headerlink" title="1. 单一职责原则"></a>1. 单一职责原则</h3><p><strong>原则</strong>：一个类应该只有一个引起变化的原因，即一个类只负责一个职责。</p><p><strong>优点</strong>：</p><ul><li>提高类的内聚性。</li><li>降低类的复杂度。</li><li>提高代码的可维护性和可读性。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReportGenerator</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">generateReport</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 生成报告的逻辑</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ReportPrinter</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printReport</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 打印报告的逻辑</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-开放封闭原则"><a href="#2-开放封闭原则" class="headerlink" title="2. 开放封闭原则"></a>2. 开放封闭原则</h3><p><strong>原则</strong>：软件实体（类、模块、函数等）应该对扩展开放，对修改封闭。</p><p><strong>优点</strong>：</p><ul><li>提高代码的可扩展性。</li><li>降低代码的修改风险。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Shape</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Shape</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Circle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 绘制圆形</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Rectangle</span> : <span class="hljs-keyword">public</span> Shape &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">draw</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 绘制矩形</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-里氏替换原则"><a href="#3-里氏替换原则" class="headerlink" title="3. 里氏替换原则"></a>3. 里氏替换原则</h3><p><strong>原则</strong>：派生类对象应该能够替换基类对象而不影响程序的正确性。</p><p><strong>优点</strong>：</p><ul><li>保证继承关系的正确性。</li><li>提高代码的可替换性和可扩展性。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Bird</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-comment">// 鸟类飞行的逻辑</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Sparrow</span> : <span class="hljs-keyword">public</span> Bird &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">fly</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 麻雀飞行的逻辑</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-接口隔离原则"><a href="#4-接口隔离原则" class="headerlink" title="4. 接口隔离原则"></a>4. 接口隔离原则</h3><p><strong>原则</strong>：一个类不应该依赖于它不使用的接口。应将接口拆分为更小、更专注的接口。</p><p><strong>优点</strong>：</p><ul><li>提高接口的内聚性。</li><li>降低类的复杂度和耦合度。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Printer</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Printer</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Scanner</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">scan</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">Scanner</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MultiFunctionPrinter</span> : <span class="hljs-keyword">public</span> Printer, <span class="hljs-keyword">public</span> Scanner &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 打印逻辑</span><br>    &#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">scan</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 扫描逻辑</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-依赖倒置原则"><a href="#5-依赖倒置原则" class="headerlink" title="5. 依赖倒置原则"></a>5. 依赖倒置原则</h3><p><strong>原则</strong>：高层模块不应该依赖于低层模块，二者都应该依赖于抽象。抽象不应该依赖于细节，细节应该依赖于抽象。</p><p><strong>优点</strong>：</p><ul><li>提高代码的灵活性和可扩展性。</li><li>降低模块之间的耦合度。</li></ul><p><strong>示例</strong>：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">IWorker</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-keyword">virtual</span> <span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>= <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">virtual</span> ~<span class="hljs-built_in">IWorker</span>() = <span class="hljs-keyword">default</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Worker</span> : <span class="hljs-keyword">public</span> IWorker &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">work</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> <span class="hljs-keyword">override</span> </span>&#123;<br>        <span class="hljs-comment">// 工作逻辑</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Manager</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">Manager</span>(IWorker* worker) : <span class="hljs-built_in">worker_</span>(worker) &#123;&#125;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">manage</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        worker_-&gt;<span class="hljs-built_in">work</span>();<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    IWorker* worker_;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="设计模式中的设计原则总结"><a href="#设计模式中的设计原则总结" class="headerlink" title="设计模式中的设计原则总结"></a>设计模式中的设计原则总结</h3><ol><li><strong>单一职责原则（SRP）</strong>：一个类只负责一个职责。</li><li><strong>开放封闭原则（OCP）</strong>：软件实体应该对扩展开放，对修改封闭。</li><li><strong>里氏替换原则（LSP）</strong>：派生类对象应该能够替换基类对象而不影响程序的正确性。</li><li><strong>接口隔离原则（ISP）</strong>：一个类不应该依赖于它不使用的接口。</li><li><strong>依赖倒置原则（DIP）</strong>：高层模块不应该依赖于低层模块，二者都应该依赖于抽象。</li></ol>]]></content>
    
    
    <categories>
      
      <category>设计模式</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>设计模式</tag>
      
      <tag>设计原则</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 定位 new</title>
    <link href="/2024/09/05/C++%20%E5%AE%9A%E4%BD%8Dnew/"/>
    <url>/2024/09/05/C++%20%E5%AE%9A%E4%BD%8Dnew/</url>
    
    <content type="html"><![CDATA[<h1 id="C-定位-new"><a href="#C-定位-new" class="headerlink" title="C++ 定位 new"></a>C++ 定位 new</h1><p>定位 <code>new</code>（placement new） 是 C++ 中的一种特殊的 <code>new</code> 运算符，用于在指定的内存地址上构造对象。它允许开发者在预先分配的内存区域中构造对象，而不是从堆中分配新的内存。这在需要精确控制内存布局或在预先分配的内存中构造对象的场景中非常有用。</p><h3 id="主要功能"><a href="#主要功能" class="headerlink" title="主要功能"></a>主要功能</h3><ul><li><strong>在指定内存地址上构造对象</strong>：定位 <code>new</code> 允许在预先分配的内存区域中构造对象。</li><li><strong>避免额外的内存分配</strong>：通过在已有的内存区域中构造对象，可以避免额外的内存分配开销。</li><li><strong>精确控制内存布局</strong>：适用于需要精确控制对象在内存中布局的场景。</li></ul><h3 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h3><p>定位 <code>new</code> 的语法如下：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">new</span> (address) <span class="hljs-built_in">Type</span>(arguments);<br></code></pre></td></tr></table></figure><ul><li><code>address</code>：指定的内存地址，通常是一个 <code>void*</code> 指针。</li><li><code>Type</code>：要构造的对象的类型。</li><li><code>arguments</code>：构造函数的参数列表。</li></ul><h3 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h3><p>以下是一些使用定位 <code>new</code> 的示例，展示了如何在指定的内存地址上构造对象。</p><h4 id="示例-1：基本使用"><a href="#示例-1：基本使用" class="headerlink" title="示例 1：基本使用"></a>示例 1：基本使用</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span> <span class="hljs-comment">// for placement new</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> value) : <span class="hljs-built_in">value_</span>(value) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass constructor: &quot;</span> &lt;&lt; value_ &lt;&lt; std::endl;<br>    &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destructor: &quot;</span> &lt;&lt; value_ &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value_ &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-comment">// 分配足够的内存来存储一个 MyClass 对象</span><br>    <span class="hljs-type">void</span>* memory = <span class="hljs-keyword">operator</span> <span class="hljs-built_in">new</span>(<span class="hljs-built_in">sizeof</span>(MyClass));<br><br>    <span class="hljs-comment">// 在指定的内存地址上构造 MyClass 对象</span><br>    MyClass* obj = <span class="hljs-built_in">new</span> (memory) <span class="hljs-built_in">MyClass</span>(<span class="hljs-number">42</span>);<br><br>    <span class="hljs-comment">// 使用对象</span><br>    obj-&gt;<span class="hljs-built_in">display</span>();<br><br>    <span class="hljs-comment">// 手动调用析构函数</span><br>    obj-&gt;~<span class="hljs-built_in">MyClass</span>();<br><br>    <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-function"><span class="hljs-keyword">operator</span> <span class="hljs-title">delete</span><span class="hljs-params">(memory)</span></span>;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="示例-2：在数组中使用定位-new"><a href="#示例-2：在数组中使用定位-new" class="headerlink" title="示例 2：在数组中使用定位 new"></a>示例 2：在数组中使用定位 <code>new</code></h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;new&gt;</span> <span class="hljs-comment">// for placement new</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> value) : <span class="hljs-built_in">value_</span>(value) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass constructor: &quot;</span> &lt;&lt; value_ &lt;&lt; std::endl; <br> &#125;<br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;MyClass destructor: &quot;</span> &lt;&lt; value_ &lt;&lt; std::endl;<br>    &#125;<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">display</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Value: &quot;</span> &lt;&lt; value_ &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> value_;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-type">const</span> <span class="hljs-type">int</span> arraySize = <span class="hljs-number">3</span>;<br><br>    <span class="hljs-comment">// 分配足够的内存来存储一个 MyClass 对象数组</span><br>    <span class="hljs-type">void</span>* memory = <span class="hljs-keyword">operator</span> <span class="hljs-keyword">new</span>[](arraySize * <span class="hljs-built_in">sizeof</span>(MyClass));<br><br>    <span class="hljs-comment">// 在指定的内存地址上构造 MyClass 对象数组</span><br>    MyClass* objArray = <span class="hljs-built_in">static_cast</span>&lt;MyClass*&gt;(memory);<br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arraySize; ++i) &#123;<br>        <span class="hljs-keyword">new</span> (&amp;objArray[i]) <span class="hljs-built_in">MyClass</span>(i * <span class="hljs-number">10</span>);<br>    &#125;<br><br>    <span class="hljs-comment">// 使用对象数组</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arraySize; ++i) &#123;<br>        objArray[i].<span class="hljs-built_in">display</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 手动调用析构函数</span><br>    <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> i = <span class="hljs-number">0</span>; i &lt; arraySize; ++i) &#123;<br>        objArray[i].~<span class="hljs-built_in">MyClass</span>();<br>    &#125;<br><br>    <span class="hljs-comment">// 释放内存</span><br>    <span class="hljs-keyword">operator</span> <span class="hljs-keyword">delete</span>[](memory);<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="注意事项"><a href="#注意事项" class="headerlink" title="注意事项"></a>注意事项</h3><ol><li><strong>手动管理内存</strong>：使用定位 <code>new</code> 时，内存的分配和释放需要手动管理。需要确保在对象的生命周期结束时正确调用析构函数，并释放内存。</li><li><strong>异常安全性</strong>：如果构造函数抛出异常，需要确保已构造的对象正确析构，并释放内存。</li><li><strong>对齐要求</strong>：确保分配的内存满足对象的对齐要求。可以使用 <code>std::align</code> 函数来调整内存对齐。</li></ol><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>**定位 <code>new</code>**：用于在指定的内存地址上构造对象，允许在预先分配的内存中构造对象。</li><li><strong>语法</strong>：<code>new (address) Type(arguments);</code></li><li><strong>手动管理内存</strong>：需要手动管理内存的分配和释放，以及对象的构造和析构。</li><li><strong>应用场景</strong>：适用于需要精确控制内存布局或在预先分配的内存中构造对象的场景。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>placement new</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>HTTP 状态码</title>
    <link href="/2024/05/05/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/"/>
    <url>/2024/05/05/HTTP%E7%8A%B6%E6%80%81%E7%A0%81/</url>
    
    <content type="html"><![CDATA[<h1 id="HTTP状态码"><a href="#HTTP状态码" class="headerlink" title="HTTP状态码"></a>HTTP状态码</h1><h2 id="消息响应"><a href="#消息响应" class="headerlink" title="消息响应"></a>消息响应</h2><table><thead><tr><th align="left">状态码</th><th align="left">原因短语</th><th align="left">代表含义</th><th align="left">HTTP 版本</th></tr></thead><tbody><tr><td align="left">100</td><td align="left">Continue(继续)</td><td align="left">客户端应当继续发送请求.这个临时响应是用来通知客户端它的部分请求已经被服务器接收,且仍未被拒绝.客户端应当继续发送请求的剩余部分,或者如果请求已经完成,忽略这个响应.服务器必须在请求完成后向客户端发送一个最终响应.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">101</td><td align="left">Switching Protocol(切换协议)</td><td align="left">服务器已经理解了客户端的请求，并将通过Upgrade消息头通知客户端采用不同的协议来完成这个请求。在发送完这个响应最后的空行后，服务器将会切换到 在Upgrade消息头中定义的那些协议。: 只有在切换新的协议更有好处的时候才应该采取类似措施。例如，切换到新的HTTP版本比旧版本更有优势，或者切换到一个实时且同步的协议以传送利用此类特 性的资源。</td><td align="left">HTTP&#x2F;1.1 可用</td></tr></tbody></table><h2 id="成功响应"><a href="#成功响应" class="headerlink" title="成功响应"></a>成功响应</h2><table><thead><tr><th align="left">状态码</th><th align="left">原因短语</th><th align="left">代表含义</th><th align="left">HTTP 版本</th></tr></thead><tbody><tr><td align="left">200</td><td align="left">OK(成功)</td><td align="left">请求成功.成功的意义根据请求所使用的方法不同而不同.- GET: 资源已被提取,并作为响应体传回客户端.- HEAD: 实体头已作为响应头传回客户端- POST: 经过服务器处理客户端传来的数据,适合的资源作为响应体传回客户端.- TRACE: 服务器收到请求消息作为响应体传回客户端.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">201</td><td align="left">Created(已创建)</td><td align="left">请求成功，而且有一个新的资源已经依据请求的需要而建立，通常这是 PUT 方法得到的响应码.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">202</td><td align="left">Accepted(已创建)</td><td align="left">服务器已接受请求，但尚未处理。正如它可能被拒绝一样，最终该请求可能会也可能不会被执行。在异步操作的场合下，没有比发送这个状态码更方便的做法了。:返回202状态码的响应的目的是允许服务器接受其他过程的请求（例如某个每天只执行一次的基于批处理的操作），而不必让客户端一直保持与服务器的连接直到批处理操作全部完成。在接受请求处理并返回202状态码的响应应当在返回的实体中包含一些指示处理当前状态的信息，以及指向处理状态监视器或状态预测的指针，以便用户能够估计操作是否已经完成。</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">203</td><td align="left">Non-Authoritative Information(未授权信息)</td><td align="left">服务器已成功处理了请求,但返回的实体头部元信息不是在原始服务器上有效的确定集合，而是来自本地或者第三方的拷贝,如果不是上述情况,使用200状态码才是最合适的.</td><td align="left">HTTP&#x2F;0.9 and 1.1</td></tr><tr><td align="left">204</td><td align="left">No Content(无内容)</td><td align="left">该响应没有响应内容,只有响应头,响应头也可能是有用的.用户代理可以根据新的响应头来更新对应资源的缓存信息.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">205</td><td align="left">Reset Content(重置内容)</td><td align="left">告诉用户代理去重置发送该请求的窗口的文档视图.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">206</td><td align="left">Partial Content(部分内容)</td><td align="left">当客户端通过使用range头字段进行文件分段下载时使用该状态码</td><td align="left">HTTP&#x2F;1.1 可用</td></tr></tbody></table><h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2><table><thead><tr><th align="left">状态码</th><th align="left">原因短语</th><th align="left">代表含义</th><th align="left">HTTP 版本</th></tr></thead><tbody><tr><td align="left">300</td><td align="left">Multiple Choice(多种选择)</td><td align="left">该请求有多种可能的响应,用户代理或者用户必须选择它们其中的一个.服务器没有任何标准可以遵循去代替用户来进行选择.</td><td align="left">HTTP&#x2F;1.0 and later</td></tr><tr><td align="left">301</td><td align="left">Moved Permanently(永久移动)</td><td align="left">该状态码表示所请求的URI资源路径已经改变,新的URL会在响应的 <code>Location</code> :头字段里找到.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">302</td><td align="left">Found(临时移动)</td><td align="left">该状态码表示所请求的URI资源路径临时改变,并且还可能继续改变.因此客户端在以后访问时还得继续使用该URI.新的URL会在响应的 <code>Location:</code> 头字段里找到.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">303</td><td align="left">See Other(查看其他位置)</td><td align="left">服务器发送该响应用来引导客户端使用GET方法访问另外一个URI.</td><td align="left">HTTP&#x2F;0.9 and 1.1</td></tr><tr><td align="left">304</td><td align="left">Not Modified(未修改)</td><td align="left">告诉客户端,所请求的内容距离上次访问并没有变化. 客户端可以直接从浏览器缓存里获取该资源.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">305</td><td align="left">Use Proxy(使用代理)</td><td align="left">所请求的资源必须统过代理才能访问到.由于安全原因,该状态码并未受到广泛支持.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">306</td><td align="left">unused(未使用)</td><td align="left">这个状态码已经不再被使用,当初它被用在HTTP 1.1规范的旧版本中.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">307</td><td align="left">Temporary Redirect(临时重定向)</td><td align="left">服务器发送该响应用来引导客户端使用相同的方法访问另外一个URI来获取想要获取的资源.新的URL会在响应的 <code>Location:</code> 头字段里找到.与302状态码有相同的语义,且前后两次访问必须使用相同的方法(GET POST).</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">308</td><td align="left">Permanent Redirect(永久重定向)</td><td align="left">所请求的资源将永久的位于另外一个URI上.新的URL会在响应的 <code>Location:</code> 头字段里找到.与301状态码有相同的语义,且前后两次访问必须使用相同的方法(GET POST).</td><td align="left">HTTPbis(试验草案)</td></tr></tbody></table><h2 id="客户端错误"><a href="#客户端错误" class="headerlink" title="客户端错误"></a>客户端错误</h2><table><thead><tr><th align="left">状态码</th><th align="left">原因短语</th><th align="left">代表含义</th><th align="left">HTTP 版本</th></tr></thead><tbody><tr><td align="left">400</td><td align="left">Bad Request(错误请求)</td><td align="left">因发送的请求语法错误,服务器无法正常读取.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">401</td><td align="left">Unauthorized(未授权)</td><td align="left">需要身份验证后才能获取所请求的内容,类似于403错误.不同点是.401错误后,只要正确输入帐号密码,验证即可通过.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">402</td><td align="left">Payment Required(需要付款)</td><td align="left">该状态码被保留以供将来使用.创建此代码最初的目的是为数字支付系统而用,然而,到现在也没投入使用.</td><td align="left">HTTP&#x2F;0.9 and 1.1</td></tr><tr><td align="left">403</td><td align="left">Forbidden(禁止访问)</td><td align="left">客户端没有权利访问所请求内容,服务器拒绝本次请求.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">404</td><td align="left">Not Found(未找到)</td><td align="left">服务器找不到所请求的资源.由于经常发生此种情况,所以该状态码在上网时是非常常见的.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">405</td><td align="left">Method Not Allowed(不允许使用该方法)</td><td align="left">该请求使用的方法被服务器端禁止使用,RFC2616中规定, <code>GET</code> 和 <code>HEAD</code> 方法不能被禁止.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">406</td><td align="left">Not Acceptable(无法接受)</td><td align="left">在进行服务器驱动内容协商后,没有发现合适的内容传回给客户端.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">407</td><td align="left">Proxy Authentication Required(要求代理身份验证)</td><td align="left">类似于状态码 401,不过需要通过代理才能进行验证.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">408</td><td align="left">Request Timeout(请求超时)</td><td align="left">客户端没有在服务器预备等待的时间内完成一个请求的发送.这意味着服务器将会切断和客户端的连接. 在其他浏览器中,这种响应更常见一些, 例如Chrome 和 IE9, 目的是为了使用HTTP 预连机制加快浏览速度. 同时注意,一些服务器不发送此种响应就直接切断连接.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">409</td><td align="left">Conflict(冲突)</td><td align="left">该请求与服务器的当前状态所冲突.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">410</td><td align="left">Gone(已失效)</td><td align="left">所请求的资源已经被删除.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">411</td><td align="left">Length Required(需要内容长度头)</td><td align="left">因服务器在本次请求中需要 <code>Content-Length</code> 头字段,而客户端没有发送.所以,服务器拒绝了该请求.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">412</td><td align="left">Precondition Failed(预处理失败)</td><td align="left">服务器没能满足客户端在获取资源时在请求头字段中设置的先决条件.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">413</td><td align="left">Request Entity Too Large(请求实体过长)</td><td align="left">请求实体大小超过服务器的设置的最大限制,服务器可能会关闭HTTP链接并返回 <code>Retry-After</code> 头字段.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">414</td><td align="left">Request-URI Too Long(请求网址过长)</td><td align="left">客户端请求所包含的URI地址太长,以至于服务器无法处理.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">415</td><td align="left">Unsupported Media Type(媒体类型不支持)</td><td align="left">服务器不支持客户端所请求的媒体类型,因此拒绝该请求.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">416</td><td align="left">Requested Range Not Satisfiable(请求范围不合要求)</td><td align="left">请求中包含的 <code>Range</code> 头字段无法被满足,通常是因为 <code>Range</code> 中的数字范围超出所请求资源的大小.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">417</td><td align="left">Expectation Failed(预期结果失败)</td><td align="left">在请求头 <code> Expect</code> 中指定的预期内容无法被服务器满足.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr></tbody></table><h2 id="服务器端错误"><a href="#服务器端错误" class="headerlink" title="服务器端错误"></a>服务器端错误</h2><table><thead><tr><th align="left">状态码</th><th align="left">原因短语</th><th align="left">代表含义</th><th align="left">HTTP 版本</th></tr></thead><tbody><tr><td align="left">500</td><td align="left">Internal Server Error(内部服务器错误)</td><td align="left">服务器遇到未知的无法解决的问题.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">501</td><td align="left">Not Implemented(未实现)</td><td align="left">服务器不支持该请求中使用的方法,比如 <code>POST</code> 和 <code>PUT.只有</code> <code>GET</code> 和 <code>HEAD</code> 是RFC2616规范中规定服务器必须实现的方法.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">502</td><td align="left">Bad Gateway(网关错误)</td><td align="left">服务器作为网关且从上游服务器获取到了一个无效的HTTP响应.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">503</td><td align="left">Service Unavailable(服务不可用)</td><td align="left">由于临时的服务器维护或者过载,服务器当前无法处理请求.这个状况是临时的,并且将在一段时间以后恢复.如果能够预计延迟时间,那么响应中可以包含一个 <code>Retry-After:</code> 头用以标明这个延迟时间.如果没有给出这个 <code>Retry-After:</code> 信息，那么客户端应当以处理500响应的方式处理它.同时,这种情况下,一个友好的用于解释服务器出现问题的页面应当被返回,并且,缓存相关的HTTP头信息也应该包含,因为通常这种错误提示网页不应当被客户端缓存.</td><td align="left">HTTP&#x2F;0.9 可用</td></tr><tr><td align="left">504</td><td align="left">Gateway Timeout(网关超时)</td><td align="left">服务器作为网关且不能从上游服务器及时的得到响应返回给客户端.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr><tr><td align="left">505</td><td align="left">HTTP Version Not Supported(HTTP版本不受支持)</td><td align="left">服务器不支持客户端发送的HTTP请求中所使用的HTTP协议版本.</td><td align="left">HTTP&#x2F;1.1 可用</td></tr></tbody></table>]]></content>
    
    
    <categories>
      
      <category>HTTP</category>
      
    </categories>
    
    
    <tags>
      
      <tag>HTTP</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Windows 关闭笔记本自带键盘</title>
    <link href="/2024/04/15/Windows%E5%85%B3%E9%97%AD%E7%AC%94%E8%AE%B0%E6%9C%AC%E9%94%AE%E7%9B%98/"/>
    <url>/2024/04/15/Windows%E5%85%B3%E9%97%AD%E7%AC%94%E8%AE%B0%E6%9C%AC%E9%94%AE%E7%9B%98/</url>
    
    <content type="html"><![CDATA[<h1 id="Windows-关闭笔记本自带键盘"><a href="#Windows-关闭笔记本自带键盘" class="headerlink" title="Windows 关闭笔记本自带键盘"></a>Windows 关闭笔记本自带键盘</h1><h2 id="关闭笔记本自带的键盘"><a href="#关闭笔记本自带的键盘" class="headerlink" title="关闭笔记本自带的键盘"></a>关闭笔记本自带的键盘</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">sc config i8042prt <span class="hljs-built_in">start</span> = disabled<br></code></pre></td></tr></table></figure><h2 id="打开笔记本自带的键盘"><a href="#打开笔记本自带的键盘" class="headerlink" title="打开笔记本自带的键盘"></a>打开笔记本自带的键盘</h2><figure class="highlight cmd"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs cmd">sc config i8042prt <span class="hljs-built_in">start</span>= auto<br></code></pre></td></tr></table></figure>]]></content>
    
    
    <categories>
      
      <category>Window 命令</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Window 命令</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Hook malloc和free 段错误调试</title>
    <link href="/2023/10/12/Hook-malloc%E5%92%8Cfree-%E6%AE%B5%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/"/>
    <url>/2023/10/12/Hook-malloc%E5%92%8Cfree-%E6%AE%B5%E9%94%99%E8%AF%AF%E8%B0%83%E8%AF%95/</url>
    
    <content type="html"><![CDATA[<h1 id="Hook-malloc-和-free-段错误调试"><a href="#Hook-malloc-和-free-段错误调试" class="headerlink" title="Hook malloc 和 free 段错误调试"></a>Hook malloc 和 free 段错误调试</h1><h2 id="1、自定义的-malloc-和-free"><a href="#1、自定义的-malloc-和-free" class="headerlink" title="1、自定义的 malloc 和 free"></a>1、自定义的 <code>malloc</code> 和 <code>free</code></h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// my_malloc.c</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">void</span>* (*real_malloc)(<span class="hljs-type">size_t</span>) = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (!real_malloc) &#123;<br>        real_malloc = dlsym(RTLD_NEXT, <span class="hljs-string">&quot;malloc&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!real_malloc) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Error in `dlsym`: %s\n&quot;</span>, dlerror());<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">void</span>* ptr = real_malloc(size);<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;malloc(%zu) = %p\n&quot;</span>, size, ptr);<br>    <span class="hljs-keyword">return</span> ptr;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*real_free)</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span> = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (!real_free) &#123;<br>        real_free = dlsym(RTLD_NEXT, <span class="hljs-string">&quot;free&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!real_free) &#123;<br>            <span class="hljs-built_in">fprintf</span>(<span class="hljs-built_in">stderr</span>, <span class="hljs-string">&quot;Error in `dlsym`: %s\n&quot;</span>, dlerror());<br>            <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;free(%p)\n&quot;</span>, ptr);<br>    real_free(ptr);<br>&#125;<br></code></pre></td></tr></table></figure><p>编译命令：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs bash">gcc -shared -fPIC -o libmymalloc.so my_malloc.c -ldl<br></code></pre></td></tr></table></figure><h2 id="2、测试程序"><a href="#2、测试程序" class="headerlink" title="2、测试程序"></a>2、测试程序</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-comment">// main.c</span><br><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">int</span> <span class="hljs-title function_">main</span><span class="hljs-params">()</span><br>&#123;<br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;enter main...\n&quot;</span>);<br><br>    <span class="hljs-type">int</span> *p = (<span class="hljs-type">int</span> *)<span class="hljs-built_in">malloc</span>(<span class="hljs-number">10</span> * <span class="hljs-keyword">sizeof</span>(<span class="hljs-type">int</span>)); <span class="hljs-comment">// 分配足够的内存</span><br>    <span class="hljs-keyword">if</span> (!p) &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;allocation error...\n&quot;</span>);<br>        <span class="hljs-built_in">exit</span>(<span class="hljs-number">1</span>);<br>    &#125;<br><br>    <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;returning to main...\n&quot;</span>);<br><br>    <span class="hljs-built_in">free</span>(p);<br><br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">strcmp</span>(<span class="hljs-string">&quot;aa&quot;</span>, <span class="hljs-string">&quot;bb&quot;</span>) == <span class="hljs-number">0</span>)<br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;hook strcmp\n&quot;</span>);<br>    &#125;<br>    <span class="hljs-keyword">else</span><br>    &#123;<br>        <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;not match\n&quot;</span>);<br>    &#125;<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><p>编译命令：</p><figure class="highlight c++"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><code class="hljs c++">gcc main.c libmymalloc.so -o main -g<br></code></pre></td></tr></table></figure><h2 id="3、运行结果（段错误）"><a href="#3、运行结果（段错误）" class="headerlink" title="3、运行结果（段错误）"></a>3、运行结果（段错误）</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs bash">linhanmic@MOSS:~/study$ ./main<br>Segmentation fault<br></code></pre></td></tr></table></figure><h2 id="4、gdb-调试"><a href="#4、gdb-调试" class="headerlink" title="4、gdb 调试"></a>4、gdb 调试</h2><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><code class="hljs bash">Temporary breakpoint 1, main () at main.c:7<br>7           <span class="hljs-built_in">printf</span>(<span class="hljs-string">&quot;enter main...\n&quot;</span>);<br>(gdb) n<br><br>Program received signal SIGSEGV, Segmentation fault.<br>0x00007ffff7e01097 <span class="hljs-keyword">in</span> __printf_buffer (buf=buf@entry=0x7fffff7ff370,<br>    format=format@entry=0x7ffff7fba01d <span class="hljs-string">&quot;malloc(%zu) = %p\n&quot;</span>, ap=ap@entry=0x7fffff7ff470, mode_flags=mode_flags@entry=0)<br>    at ./stdio-common/vfprintf-internal.c:600<br></code></pre></td></tr></table></figure><h2 id="5、错误分析"><a href="#5、错误分析" class="headerlink" title="5、错误分析"></a>5、错误分析</h2><p>根据调试信息发现，段错误发生在 <code>printf</code> 函数中，由于 <code>printf</code> 函数内部调用了 <code>malloc</code> ，而 hook 后的 <code>malloc</code> 内部又调用了 <code>printf</code> 函数，导致函数 <code>递归调用</code> 造成 <code>栈溢出</code>，出现 <code>Segmentation fault</code> 。</p><h2 id="6、解决方案"><a href="#6、解决方案" class="headerlink" title="6、解决方案"></a>6、解决方案</h2><p>避免在<code>malloc</code>和<code>free</code>中调用<code>printf</code>：可以使用<code>write</code>函数代替<code>printf</code>，因为<code>write</code>是一个系统调用，不会调用<code>malloc</code>。</p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br></pre></td><td class="code"><pre><code class="hljs c"><span class="hljs-meta">#<span class="hljs-keyword">define</span> _GNU_SOURCE</span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdio.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;stdlib.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;dlfcn.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;unistd.h&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;string.h&gt;</span></span><br><br><span class="hljs-type">void</span>* <span class="hljs-title function_">malloc</span><span class="hljs-params">(<span class="hljs-type">size_t</span> size)</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-type">void</span>* (*real_malloc)(<span class="hljs-type">size_t</span>) = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (!real_malloc) &#123;<br>        real_malloc = dlsym(RTLD_NEXT, <span class="hljs-string">&quot;malloc&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!real_malloc) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">char</span> *error = <span class="hljs-string">&quot;Error in `dlsym` for `malloc`\n&quot;</span>;<br>            write(STDERR_FILENO, error, <span class="hljs-built_in">strlen</span>(error));<br>            _exit(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">void</span>* ptr = real_malloc(size);<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">256</span>];<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">snprintf</span>(buffer, <span class="hljs-keyword">sizeof</span>(buffer), <span class="hljs-string">&quot;malloc(%zu) = %p\n&quot;</span>, size, ptr);<br>    write(STDOUT_FILENO, buffer, len);<br>    <span class="hljs-keyword">return</span> ptr;<br>&#125;<br><br><span class="hljs-type">void</span> <span class="hljs-title function_">free</span><span class="hljs-params">(<span class="hljs-type">void</span>* ptr)</span> &#123;<br>    <span class="hljs-type">static</span> <span class="hljs-title function_">void</span> <span class="hljs-params">(*real_free)</span><span class="hljs-params">(<span class="hljs-type">void</span>*)</span> = <span class="hljs-literal">NULL</span>;<br>    <span class="hljs-keyword">if</span> (!real_free) &#123;<br>        real_free = dlsym(RTLD_NEXT, <span class="hljs-string">&quot;free&quot;</span>);<br>        <span class="hljs-keyword">if</span> (!real_free) &#123;<br>            <span class="hljs-type">const</span> <span class="hljs-type">char</span> *error = <span class="hljs-string">&quot;Error in `dlsym` for `free`\n&quot;</span>;<br>            write(STDERR_FILENO, error, <span class="hljs-built_in">strlen</span>(error));<br>            _exit(<span class="hljs-number">1</span>);<br>        &#125;<br>    &#125;<br>    <span class="hljs-type">char</span> buffer[<span class="hljs-number">256</span>];<br>    <span class="hljs-type">int</span> len = <span class="hljs-built_in">snprintf</span>(buffer, <span class="hljs-keyword">sizeof</span>(buffer), <span class="hljs-string">&quot;free(%p)\n&quot;</span>, ptr);<br>    write(STDOUT_FILENO, buffer, len);<br>    real_free(ptr);<br>&#125;<br></code></pre></td></tr></table></figure><p>修改后的运行结果：</p><figure class="highlight bash"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs bash">linhanmic@MOSS:~/study$ ./main<br>malloc(1024) = 0x558cae5fa2a0<br>enter main...<br>malloc(40) = 0x558cae5fa6b0<br>returning to main...<br>free(0x558cae5fa6b0)<br>not match<br></code></pre></td></tr></table></figure><h2 id="7、总结"><a href="#7、总结" class="headerlink" title="7、总结"></a>7、总结</h2><p>1、在 hook 时调用其他函数，由于不知道函数内部实现容易出现递归调用导致栈溢出</p><p>2、善用 <code>gdb</code> 调试程序能够快速地定位错误，达到事半功倍的效果</p>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
      <category>Debug</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>Hook</tag>
      
      <tag>Segmentation fault</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 类之构造函数</title>
    <link href="/2023/10/06/C++%20%E7%B1%BB%E4%B9%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/"/>
    <url>/2023/10/06/C++%20%E7%B1%BB%E4%B9%8B%E6%9E%84%E9%80%A0%E5%87%BD%E6%95%B0/</url>
    
    <content type="html"><![CDATA[<h1 id="C-类之构造函数"><a href="#C-类之构造函数" class="headerlink" title="C++ 类之构造函数"></a>C++ 类之构造函数</h1><p>在C++中，构造函数是用于初始化对象的特殊成员函数。构造函数有多种类型，包括默认构造函数、参数化构造函数、拷贝构造函数和移动构造函数。以下是对这些构造函数的详细总结和解释。</p><h3 id="1-默认构造函数"><a href="#1-默认构造函数" class="headerlink" title="1. 默认构造函数"></a>1. 默认构造函数</h3><p>默认构造函数是在没有参数的情况下创建对象时调用的构造函数。如果没有显式定义，编译器会生成一个默认构造函数。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>() &#123;<br>        <span class="hljs-comment">// 默认构造函数</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-参数化构造函数"><a href="#2-参数化构造函数" class="headerlink" title="2. 参数化构造函数"></a>2. 参数化构造函数</h3><p>参数化构造函数允许在创建对象时传递参数，以初始化对象的成员变量。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">double</span> y) : <span class="hljs-built_in">a</span>(x), <span class="hljs-built_in">b</span>(y) &#123;<br>        <span class="hljs-comment">// 参数化构造函数</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">double</span> b;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-拷贝构造函数"><a href="#3-拷贝构造函数" class="headerlink" title="3. 拷贝构造函数"></a>3. 拷贝构造函数</h3><p>拷贝构造函数用于通过另一个同类型的对象来初始化新对象。它通常用于复制对象的资源。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp; other) : <span class="hljs-built_in">a</span>(other.a), <span class="hljs-built_in">b</span>(other.b) &#123;<br>        <span class="hljs-comment">// 拷贝构造函数</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">double</span> b;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-移动构造函数"><a href="#4-移动构造函数" class="headerlink" title="4. 移动构造函数"></a>4. 移动构造函数</h3><p>移动构造函数用于通过移动另一个同类型的对象来初始化新对象。它通常用于转移对象的资源，而不是复制它们。</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">a</span>(other.a), <span class="hljs-built_in">b</span>(other.b) &#123;<br>        other.a = <span class="hljs-number">0</span>;<br>        other.b = <span class="hljs-number">0.0</span>;<br>        <span class="hljs-comment">// 移动构造函数</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">double</span> b;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-析构函数"><a href="#5-析构函数" class="headerlink" title="5. 析构函数"></a>5. 析构函数</h3><p>析构函数用于在对象生命周期结束时清理资源。它的名称与类名相同，但前面有一个波浪号（<code>~</code>）。</p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        <span class="hljs-comment">// 析构函数</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="6-完整示例"><a href="#6-完整示例" class="headerlink" title="6. 完整示例"></a>6. 完整示例</h3><p>以下是一个包含所有类型构造函数和析构函数的完整示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span> <span class="hljs-comment">// for std::move</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">MyClass</span>() : <span class="hljs-built_in">a</span>(<span class="hljs-number">0</span>), <span class="hljs-built_in">b</span>(<span class="hljs-number">0.0</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Default constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 参数化构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> x, <span class="hljs-type">double</span> y) : <span class="hljs-built_in">a</span>(x), <span class="hljs-built_in">b</span>(y) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Parameterized constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp; other) : <span class="hljs-built_in">a</span>(other.a), <span class="hljs-built_in">b</span>(other.b) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Copy constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">a</span>(other.a), <span class="hljs-built_in">b</span>(other.b) &#123;<br>        other.a = <span class="hljs-number">0</span>;<br>        other.b = <span class="hljs-number">0.0</span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Move constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印数据</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;a: &quot;</span> &lt;&lt; a &lt;&lt; <span class="hljs-string">&quot;, b: &quot;</span> &lt;&lt; b &lt;&lt; std::endl;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>    <span class="hljs-type">double</span> b;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj1; <span class="hljs-comment">// 调用默认构造函数</span><br>    <span class="hljs-function">MyClass <span class="hljs-title">obj2</span><span class="hljs-params">(<span class="hljs-number">10</span>, <span class="hljs-number">20.5</span>)</span></span>; <span class="hljs-comment">// 调用参数化构造函数</span><br>    MyClass obj3 = obj2; <span class="hljs-comment">// 调用拷贝构造函数</span><br>    MyClass obj4 = std::<span class="hljs-built_in">move</span>(obj2); <span class="hljs-comment">// 调用移动构造函数</span><br><br>    obj<span class="hljs-number">1.</span><span class="hljs-built_in">print</span>();<br>    obj<span class="hljs-number">2.</span><span class="hljs-built_in">print</span>(); <span class="hljs-comment">// 被移动后，obj2 的值被重置</span><br>    obj<span class="hljs-number">3.</span><span class="hljs-built_in">print</span>();<br>    obj<span class="hljs-number">4.</span><span class="hljs-built_in">print</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs delphi"><span class="hljs-keyword">Default</span> <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Parameterized</span> <span class="hljs-title">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Copy</span> <span class="hljs-title">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Move</span> <span class="hljs-title">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">a</span>:</span> <span class="hljs-number">0</span>, b: <span class="hljs-number">0</span><br>a: <span class="hljs-number">0</span>, b: <span class="hljs-number">0</span><br>a: <span class="hljs-number">10</span>, b: <span class="hljs-number">20.5</span><br>a: <span class="hljs-number">10</span>, b: <span class="hljs-number">20.5</span><br><span class="hljs-function"><span class="hljs-keyword">Destructor</span></span><br><span class="hljs-function"><span class="hljs-title">Destructor</span></span><br><span class="hljs-function"><span class="hljs-title">Destructor</span></span><br><span class="hljs-function"><span class="hljs-title">Destructor</span></span><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>默认构造函数</strong>：在没有参数的情况下创建对象时调用。</li><li><strong>参数化构造函数</strong>：允许在创建对象时传递参数，以初始化对象的成员变量。</li><li><strong>拷贝构造函数</strong>：通过另一个同类型的对象来初始化新对象，通常用于复制对象的资源。</li><li><strong>移动构造函数</strong>：通过移动另一个同类型的对象来初始化新对象，通常用于转移对象的资源。</li><li><strong>析构函数</strong>：在对象生命周期结束时清理资源。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>构造函数</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 类之拷贝控制</title>
    <link href="/2023/10/05/C++%20%E7%B1%BB%E4%B9%8B%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/"/>
    <url>/2023/10/05/C++%20%E7%B1%BB%E4%B9%8B%E6%8B%B7%E8%B4%9D%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="C-类之拷贝控制"><a href="#C-类之拷贝控制" class="headerlink" title="C++ 类之拷贝控制"></a>C++ 类之拷贝控制</h1><p>在C++中，拷贝控制（Copy Control）是指管理对象的复制、移动和销毁的机制。拷贝控制主要涉及以下五个成员函数：</p><ol><li>拷贝构造函数（Copy Constructor）</li><li>拷贝赋值运算符（Copy Assignment Operator）</li><li>移动构造函数（Move Constructor）</li><li>移动赋值运算符（Move Assignment Operator）</li><li>析构函数（Destructor）</li></ol><p>这些成员函数共同负责对象的生命周期管理，包括对象的创建、复制、移动和销毁。</p><h3 id="1-拷贝构造函数"><a href="#1-拷贝构造函数" class="headerlink" title="1. 拷贝构造函数"></a>1. 拷贝构造函数</h3><p>拷贝构造函数用于通过另一个同类型的对象来初始化新对象。它通常用于复制对象的资源。</p><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp; other) : <span class="hljs-built_in">a</span>(other.a) &#123;<br>        <span class="hljs-comment">// 拷贝构造函数</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="2-拷贝赋值运算符"><a href="#2-拷贝赋值运算符" class="headerlink" title="2. 拷贝赋值运算符"></a>2. 拷贝赋值运算符</h3><p>拷贝赋值运算符用于将一个已有对象的资源复制到另一个已有对象中。</p><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    MyClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            a = other.a;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> a;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="3-移动构造函数"><a href="#3-移动构造函数" class="headerlink" title="3. 移动构造函数"></a>3. 移动构造函数</h3><p>移动构造函数用于通过移动另一个同类型的对象来初始化新对象。它通常用于转移对象的资源，而不是复制它们。</p><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">a</span>(other.a) &#123;<br>        other.a = <span class="hljs-literal">nullptr</span>;<br>        <span class="hljs-comment">// 移动构造函数</span><br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* a;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="4-移动赋值运算符"><a href="#4-移动赋值运算符" class="headerlink" title="4. 移动赋值运算符"></a>4. 移动赋值运算符</h3><p>移动赋值运算符用于将一个已有对象的资源移动到另一个已有对象中。</p><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    MyClass&amp; <span class="hljs-keyword">operator</span>=(MyClass&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-keyword">delete</span> a;<br>            a = other.a;<br>            other.a = <span class="hljs-literal">nullptr</span>;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* a;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="5-析构函数"><a href="#5-析构函数" class="headerlink" title="5. 析构函数"></a>5. 析构函数</h3><p>析构函数用于在对象生命周期结束时清理资源。它的名称与类名相同，但前面有一个波浪号（<code>~</code>）。</p><h4 id="示例-4"><a href="#示例-4" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        <span class="hljs-comment">// 析构函数</span><br>    &#125;<br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="拷贝控制的规则"><a href="#拷贝控制的规则" class="headerlink" title="拷贝控制的规则"></a>拷贝控制的规则</h3><p>C++11引入了”Rule of Three”和”Rule of Five”来帮助开发者管理拷贝控制函数。</p><h4 id="Rule-of-Three"><a href="#Rule-of-Three" class="headerlink" title="Rule of Three"></a>Rule of Three</h4><p>如果一个类需要自定义拷贝构造函数、拷贝赋值运算符或析构函数中的任何一个，那么它很可能需要自定义所有这三个函数。</p><h4 id="Rule-of-Five"><a href="#Rule-of-Five" class="headerlink" title="Rule of Five"></a>Rule of Five</h4><p>C++11引入了移动语义，因此如果一个类需要自定义拷贝构造函数、拷贝赋值运算符、移动构造函数、移动赋值运算符或析构函数中的任何一个，那么它很可能需要自定义所有这五个函数。</p><h3 id="完整示例"><a href="#完整示例" class="headerlink" title="完整示例"></a>完整示例</h3><p>以下是一个包含所有拷贝控制函数的完整示例：</p><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;iostream&gt;</span></span><br><span class="hljs-meta">#<span class="hljs-keyword">include</span> <span class="hljs-string">&lt;utility&gt;</span> <span class="hljs-comment">// for std::move</span></span><br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-comment">// 默认构造函数</span><br>    <span class="hljs-built_in">MyClass</span>() : <span class="hljs-built_in">a</span>(<span class="hljs-literal">nullptr</span>) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Default constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 参数化构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">a</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(x)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Parameterized constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">const</span> MyClass&amp; other) : <span class="hljs-built_in">a</span>(<span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.a)) &#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Copy constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动构造函数</span><br>    <span class="hljs-built_in">MyClass</span>(MyClass&amp;&amp; other) <span class="hljs-keyword">noexcept</span> : <span class="hljs-built_in">a</span>(other.a) &#123;<br>        other.a = <span class="hljs-literal">nullptr</span>;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Move constructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 拷贝赋值运算符</span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>=(<span class="hljs-type">const</span> MyClass&amp; other) &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-keyword">delete</span> a;<br>            a = <span class="hljs-keyword">new</span> <span class="hljs-built_in">int</span>(*other.a);<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Copy assignment operator&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 移动赋值运算符</span><br>    MyClass&amp; <span class="hljs-keyword">operator</span>=(MyClass&amp;&amp; other) <span class="hljs-keyword">noexcept</span> &#123;<br>        <span class="hljs-keyword">if</span> (<span class="hljs-keyword">this</span> != &amp;other) &#123;<br>            <span class="hljs-keyword">delete</span> a;<br>            a = other.a;<br>            other.a = <span class="hljs-literal">nullptr</span>;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;Move assignment operator&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>        <span class="hljs-keyword">return</span> *<span class="hljs-keyword">this</span>;<br>    &#125;<br><br>    <span class="hljs-comment">// 析构函数</span><br>    ~<span class="hljs-built_in">MyClass</span>() &#123;<br>        <span class="hljs-keyword">delete</span> a;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Destructor&quot;</span> &lt;&lt; std::endl;<br>    &#125;<br><br>    <span class="hljs-comment">// 打印数据</span><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">print</span><span class="hljs-params">()</span> <span class="hljs-type">const</span> </span>&#123;<br>        <span class="hljs-keyword">if</span> (a) &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;a: &quot;</span> &lt;&lt; *a &lt;&lt; std::endl;<br>        &#125; <span class="hljs-keyword">else</span> &#123;<br>            std::cout &lt;&lt; <span class="hljs-string">&quot;a is null&quot;</span> &lt;&lt; std::endl;<br>        &#125;<br>    &#125;<br><br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span>* a;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj1</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>; <span class="hljs-comment">// 调用参数化构造函数</span><br>    MyClass obj2 = obj1; <span class="hljs-comment">// 调用拷贝构造函数</span><br>    MyClass obj3 = std::<span class="hljs-built_in">move</span>(obj1); <span class="hljs-comment">// 调用移动构造函数</span><br><br>    <span class="hljs-function">MyClass <span class="hljs-title">obj4</span><span class="hljs-params">(<span class="hljs-number">20</span>)</span></span>; <span class="hljs-comment">// 调用参数化构造函数</span><br>    obj4 = obj2; <span class="hljs-comment">// 调用拷贝赋值运算符</span><br>    obj4 = std::<span class="hljs-built_in">move</span>(obj3); <span class="hljs-comment">// 调用移动赋值运算符</span><br><br>    obj<span class="hljs-number">1.</span><span class="hljs-built_in">print</span>(); <span class="hljs-comment">// 被移动后，obj1 的值被重置</span><br>    obj<span class="hljs-number">2.</span><span class="hljs-built_in">print</span>();<br>    obj<span class="hljs-number">3.</span><span class="hljs-built_in">print</span>(); <span class="hljs-comment">// 被移动后，obj3 的值被重置</span><br>    obj<span class="hljs-number">4.</span><span class="hljs-built_in">print</span>();<br><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h3><figure class="highlight delphi"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs delphi">Parameterized <span class="hljs-function"><span class="hljs-keyword">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Copy</span> <span class="hljs-title">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Move</span> <span class="hljs-title">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Parameterized</span> <span class="hljs-title">constructor</span></span><br><span class="hljs-function"><span class="hljs-title">Copy</span> <span class="hljs-title">assignment</span> <span class="hljs-title">operator</span></span><br><span class="hljs-function"><span class="hljs-title">Move</span> <span class="hljs-title">assignment</span> <span class="hljs-title">operator</span></span><br><span class="hljs-function"><span class="hljs-title">a</span> <span class="hljs-title">is</span> <span class="hljs-title">null</span></span><br><span class="hljs-function"><span class="hljs-title">a</span>:</span> <span class="hljs-number">10</span><br>a <span class="hljs-keyword">is</span> null<br>a: <span class="hljs-number">10</span><br><span class="hljs-function"><span class="hljs-keyword">Destructor</span></span><br><span class="hljs-function"><span class="hljs-title">Destructor</span></span><br><span class="hljs-function"><span class="hljs-title">Destructor</span></span><br><span class="hljs-function"><span class="hljs-title">Destructor</span></span><br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li><strong>拷贝构造函数</strong>：用于通过另一个同类型的对象来初始化新对象。</li><li><strong>拷贝赋值运算符</strong>：用于将一个已有对象的资源复制到另一个已有对象中。</li><li><strong>移动构造函数</strong>：用于通过移动另一个同类型的对象来初始化新对象。</li><li><strong>移动赋值运算符</strong>：用于将一个已有对象的资源移动到另一个已有对象中。</li><li><strong>析构函数</strong>：用于在对象生命周期结束时清理资源。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>拷贝控制</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>Vim -多行注释</title>
    <link href="/2023/09/05/Vim-%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A/"/>
    <url>/2023/09/05/Vim-%E5%A4%9A%E8%A1%8C%E6%B3%A8%E9%87%8A/</url>
    
    <content type="html"><![CDATA[<h1 id="Vim-多行注释"><a href="#Vim-多行注释" class="headerlink" title="Vim -多行注释"></a>Vim -多行注释</h1><p>操作步骤如下：</p><ol><li>移动光标到要注释的起始行的行首</li><li>Ctrl + q 进入可视块模式</li><li>移动光标选中要注释的代码行</li><li>Shift + i 进入插入模式，键入当前语言的注释符</li><li>按Esc键后，之前选中的代码行会全部加上了注释符</li></ol><p>其实，这里并不局限于注释代码，这里的操作叫<code>列插入</code>更合适，也就是可以在多行代码的同一列插入同样的任意字符。</p>]]></content>
    
    
    <categories>
      
      <category>Vim</category>
      
    </categories>
    
    
    <tags>
      
      <tag>Vim</tag>
      
    </tags>
    
  </entry>
  
  
  
  <entry>
    <title>C++ 类之访问控制</title>
    <link href="/2023/07/05/C++%20%E7%B1%BB%E4%B9%8B%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/"/>
    <url>/2023/07/05/C++%20%E7%B1%BB%E4%B9%8B%E8%AE%BF%E9%97%AE%E6%8E%A7%E5%88%B6/</url>
    
    <content type="html"><![CDATA[<h1 id="C-类之访问控制"><a href="#C-类之访问控制" class="headerlink" title="C++ 类之访问控制"></a>C++ 类之访问控制</h1><p>在C++中，访问控制（Access Control）是指控制类成员（变量和函数）的访问权限。访问控制通过访问说明符（Access Specifiers）来实现，主要有以下三种：</p><ol><li><code>public</code>：公有访问权限</li><li><code>protected</code>：受保护访问权限</li><li><code>private</code>：私有访问权限</li></ol><p>此外，C++还提供了友元函数和友元类机制，以允许特定的非成员函数或类访问类的私有和受保护成员。</p><h3 id="1-public-访问权限"><a href="#1-public-访问权限" class="headerlink" title="1. public 访问权限"></a>1. <code>public</code> 访问权限</h3><ul><li><strong>描述</strong>：公有成员可以在类的外部被访问。</li><li><strong>应用场景</strong>：用于需要在类的外部访问的成员，如接口函数。</li></ul><h4 id="示例"><a href="#示例" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> publicVar;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">publicMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 公有方法</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    obj.publicVar = <span class="hljs-number">10</span>; <span class="hljs-comment">// 访问公有成员变量</span><br>    obj.<span class="hljs-built_in">publicMethod</span>(); <span class="hljs-comment">// 调用公有成员函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="2-protected-访问权限"><a href="#2-protected-访问权限" class="headerlink" title="2. protected 访问权限"></a>2. <code>protected</code> 访问权限</h3><ul><li><strong>描述</strong>：受保护成员可以在类的内部和派生类中被访问，但不能在类的外部被访问。</li><li><strong>应用场景</strong>：用于需要在派生类中访问但不希望在类的外部访问的成员。</li></ul><h4 id="示例-1"><a href="#示例-1" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> protectedVar;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">protectedMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 受保护方法</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">Derived</span> : <span class="hljs-keyword">public</span> Base &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">accessProtected</span><span class="hljs-params">()</span> </span>&#123;<br>        protectedVar = <span class="hljs-number">10</span>; <span class="hljs-comment">// 访问基类的受保护成员变量</span><br>        <span class="hljs-built_in">protectedMethod</span>(); <span class="hljs-comment">// 调用基类的受保护成员函数</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    Derived obj;<br>    obj.<span class="hljs-built_in">accessProtected</span>();<br>    <span class="hljs-comment">// obj.protectedVar = 10; // 错误：不能在类的外部访问受保护成员</span><br>    <span class="hljs-comment">// obj.protectedMethod(); // 错误：不能在类的外部调用受保护成员函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="3-private-访问权限"><a href="#3-private-访问权限" class="headerlink" title="3. private 访问权限"></a>3. <code>private</code> 访问权限</h3><ul><li><strong>描述</strong>：私有成员仅可以在类的内部被访问，不能在类的外部或派生类中被访问。</li><li><strong>应用场景</strong>：用于仅在类的内部访问的成员，通常用于实现细节。</li></ul><h4 id="示例-2"><a href="#示例-2" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> privateVar;<br><br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">privateMethod</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-comment">// 私有方法</span><br>    &#125;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">accessPrivate</span><span class="hljs-params">()</span> </span>&#123;<br>        privateVar = <span class="hljs-number">10</span>; <span class="hljs-comment">// 访问私有成员变量</span><br>        <span class="hljs-built_in">privateMethod</span>(); <span class="hljs-comment">// 调用私有成员函数</span><br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    MyClass obj;<br>    obj.<span class="hljs-built_in">accessPrivate</span>();<br>    <span class="hljs-comment">// obj.privateVar = 10; // 错误：不能在类的外部访问私有成员</span><br>    <span class="hljs-comment">// obj.privateMethod(); // 错误：不能在类的外部调用私有成员函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="4-友元函数和友元类"><a href="#4-友元函数和友元类" class="headerlink" title="4. 友元函数和友元类"></a>4. 友元函数和友元类</h3><ul><li><strong>友元函数</strong>：非成员函数，但被授予访问类的私有和受保护成员的权限。常用于操作符重载和辅助函数。</li><li><strong>友元类</strong>：一个类，被授予访问另一个类的私有和受保护成员的权限。常用于紧密耦合的类之间的合作。</li></ul><h4 id="友元函数示例"><a href="#友元函数示例" class="headerlink" title="友元函数示例"></a>友元函数示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> privateVar;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">privateVar</span>(x) &#123;&#125;<br><br>    <span class="hljs-comment">// 声明友元函数</span><br>    <span class="hljs-function"><span class="hljs-keyword">friend</span> <span class="hljs-type">void</span> <span class="hljs-title">printPrivateVar</span><span class="hljs-params">(<span class="hljs-type">const</span> MyClass&amp; obj)</span></span>;<br>&#125;;<br><br><span class="hljs-comment">// 定义友元函数</span><br><span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPrivateVar</span><span class="hljs-params">(<span class="hljs-type">const</span> MyClass&amp; obj)</span> </span>&#123;<br>    std::cout &lt;&lt; <span class="hljs-string">&quot;Private variable: &quot;</span> &lt;&lt; obj.privateVar &lt;&lt; std::endl;<br>&#125;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    <span class="hljs-built_in">printPrivateVar</span>(obj); <span class="hljs-comment">// 调用友元函数</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h4 id="友元类示例"><a href="#友元类示例" class="headerlink" title="友元类示例"></a>友元类示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">MyClass</span> &#123;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> privateVar;<br><br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-built_in">MyClass</span>(<span class="hljs-type">int</span> x) : <span class="hljs-built_in">privateVar</span>(x) &#123;&#125;<br><br>    <span class="hljs-comment">// 声明友元类</span><br>    <span class="hljs-keyword">friend</span> <span class="hljs-keyword">class</span> <span class="hljs-title class_">FriendClass</span>;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">FriendClass</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-function"><span class="hljs-type">void</span> <span class="hljs-title">printPrivateVar</span><span class="hljs-params">(<span class="hljs-type">const</span> MyClass&amp; obj)</span> </span>&#123;<br>        std::cout &lt;&lt; <span class="hljs-string">&quot;Private variable: &quot;</span> &lt;&lt; obj.privateVar &lt;&lt; std::endl;<br>    &#125;<br>&#125;;<br><br><span class="hljs-function"><span class="hljs-type">int</span> <span class="hljs-title">main</span><span class="hljs-params">()</span> </span>&#123;<br>    <span class="hljs-function">MyClass <span class="hljs-title">obj</span><span class="hljs-params">(<span class="hljs-number">10</span>)</span></span>;<br>    FriendClass friendObj;<br>    friendObj.<span class="hljs-built_in">printPrivateVar</span>(obj); <span class="hljs-comment">// 调用友元类的方法</span><br>    <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>&#125;<br></code></pre></td></tr></table></figure><h3 id="5-访问控制的继承关系"><a href="#5-访问控制的继承关系" class="headerlink" title="5. 访问控制的继承关系"></a>5. 访问控制的继承关系</h3><p>在继承关系中，基类的访问控制会影响派生类对基类成员的访问权限。继承方式有三种：<code>public</code> 继承、<code>protected</code> 继承和 <code>private</code> 继承。</p><h4 id="public-继承"><a href="#public-继承" class="headerlink" title="public 继承"></a><code>public</code> 继承</h4><ul><li>基类的 <code>public</code> 成员在派生类中仍然是 <code>public</code>。</li><li>基类的 <code>protected</code> 成员在派生类中仍然是 <code>protected</code>。</li></ul><h4 id="protected-继承"><a href="#protected-继承" class="headerlink" title="protected 继承"></a><code>protected</code> 继承</h4><ul><li>基类的 <code>public</code> 成员在派生类中变为 <code>protected</code>。</li><li>基类的 <code>protected</code> 成员在派生类中仍然是 <code>protected</code>。</li></ul><h4 id="private-继承"><a href="#private-继承" class="headerlink" title="private 继承"></a><code>private</code> 继承</h4><ul><li>基类的 <code>public</code> 和 <code>protected</code> 成员在派生类中都变为 <code>private</code>。</li></ul><h4 id="示例-3"><a href="#示例-3" class="headerlink" title="示例"></a>示例</h4><figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Base</span> &#123;<br><span class="hljs-keyword">public</span>:<br>    <span class="hljs-type">int</span> publicVar;<br><span class="hljs-keyword">protected</span>:<br>    <span class="hljs-type">int</span> protectedVar;<br><span class="hljs-keyword">private</span>:<br>    <span class="hljs-type">int</span> privateVar;<br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PublicDerived</span> : <span class="hljs-keyword">public</span> Base &#123;<br>    <span class="hljs-comment">// publicVar 是 public</span><br>    <span class="hljs-comment">// protectedVar 是 protected</span><br>    <span class="hljs-comment">// privateVar 不能访问</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">ProtectedDerived</span> : <span class="hljs-keyword">protected</span> Base &#123;<br>    <span class="hljs-comment">// publicVar 是 protected</span><br>    <span class="hljs-comment">// protectedVar 是 protected</span><br>    <span class="hljs-comment">// privateVar 不能访问</span><br>&#125;;<br><br><span class="hljs-keyword">class</span> <span class="hljs-title class_">PrivateDerived</span> : <span class="hljs-keyword">private</span> Base &#123;<br>    <span class="hljs-comment">// publicVar 是 private</span><br>    <span class="hljs-comment">// protectedVar 是 private</span><br>    <span class="hljs-comment">// privateVar 不能访问</span><br>&#125;;<br></code></pre></td></tr></table></figure><h3 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h3><ul><li>**<code>public</code>**：公有访问权限，允许类的成员在类的外部被访问。</li><li>**<code>protected</code>**：受保护访问权限，允许类的成员在类的内部和派生类中被访问。</li><li>**<code>private</code>**：私有访问权限，允许类的成员仅在类的内部被访问。</li><li><strong>友元函数和友元类</strong>：允许特定的非成员函数或类访问类的私有和受保护成员。</li><li><strong>继承关系中的访问控制</strong>：基类的访问控制会影响派生类对基类成员的访问权限，具体取决于继承方式（<code>public</code>、<code>protected</code>、<code>private</code>）。</li></ul>]]></content>
    
    
    <categories>
      
      <category>C++</category>
      
    </categories>
    
    
    <tags>
      
      <tag>C++</tag>
      
      <tag>访问控制</tag>
      
    </tags>
    
  </entry>
  
  
  
  
</search>
